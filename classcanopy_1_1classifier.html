<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Canopy: canopy::classifier&lt; TNumParams &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Canopy
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">The header-only random forests library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecanopy.html">canopy</a></li><li class="navelem"><a class="el" href="classcanopy_1_1classifier.html">classifier</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classcanopy_1_1classifier-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">canopy::classifier&lt; TNumParams &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implements a random forest classifier model to predict a discrete output label.  
 <a href="classcanopy_1_1classifier.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="classifier_8hpp_source.html">classifier.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for canopy::classifier&lt; TNumParams &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classcanopy_1_1classifier__inherit__graph.png" border="0" usemap="#canopy_1_1classifier_3_01_t_num_params_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="canopy_1_1classifier_3_01_t_num_params_01_4_inherit__map" id="canopy_1_1classifier_3_01_t_num_params_01_4_inherit__map">
<area shape="rect" id="node2" href="classcanopy_1_1random_forest_base.html" title="canopy::randomForestBase\l\&lt; classifier\&lt; TNumParams\l \&gt;, int, discreteDistribution,\l discreteDistribution, TNumParams \&gt;" alt="" coords="5,5,244,76"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for canopy::classifier&lt; TNumParams &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classcanopy_1_1classifier__coll__graph.png" border="0" usemap="#canopy_1_1classifier_3_01_t_num_params_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="canopy_1_1classifier_3_01_t_num_params_01_4_coll__map" id="canopy_1_1classifier_3_01_t_num_params_01_4_coll__map">
<area shape="rect" id="node2" href="classcanopy_1_1random_forest_base.html" title="canopy::randomForestBase\l\&lt; classifier\&lt; TNumParams\l \&gt;, int, discreteDistribution,\l discreteDistribution, TNumParams \&gt;" alt="" coords="5,5,244,76"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a17e8bdd1d3ed477a375a4eefc6c2432b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1classifier.html#a17e8bdd1d3ed477a375a4eefc6c2432b">classifier</a> (const int num_classes, const int num_trees, const int num_levels, const double info_gain_tresh=<a class="el" href="classcanopy_1_1classifier.html#a4d7d06e0316f7ceca7007c6f26dadc0f">C_DEFAULT_MIN_INFO_GAIN</a>)</td></tr>
<tr class="memdesc:a17e8bdd1d3ed477a375a4eefc6c2432b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full constructor.  <a href="#a17e8bdd1d3ed477a375a4eefc6c2432b">More...</a><br /></td></tr>
<tr class="separator:a17e8bdd1d3ed477a375a4eefc6c2432b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120e1aa5231540f18a6d58124a77ab0b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1classifier.html#a120e1aa5231540f18a6d58124a77ab0b">classifier</a> ()</td></tr>
<tr class="memdesc:a120e1aa5231540f18a6d58124a77ab0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a120e1aa5231540f18a6d58124a77ab0b">More...</a><br /></td></tr>
<tr class="separator:a120e1aa5231540f18a6d58124a77ab0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f1330730c050bf69ae1f3835df0bff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1classifier.html#af3f1330730c050bf69ae1f3835df0bff">getNumberClasses</a> () const </td></tr>
<tr class="memdesc:af3f1330730c050bf69ae1f3835df0bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of classes in the discrete label space of the model.  <a href="#af3f1330730c050bf69ae1f3835df0bff">More...</a><br /></td></tr>
<tr class="separator:af3f1330730c050bf69ae1f3835df0bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2058bb3b63989760a929d54846356314"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1classifier.html#a2058bb3b63989760a929d54846356314">setClassNames</a> (const std::vector&lt; std::string &gt; &amp;new_class_names)</td></tr>
<tr class="memdesc:a2058bb3b63989760a929d54846356314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the class name strings.  <a href="#a2058bb3b63989760a929d54846356314">More...</a><br /></td></tr>
<tr class="separator:a2058bb3b63989760a929d54846356314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35dec8c2204ab75023062ba7900b4fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1classifier.html#af35dec8c2204ab75023062ba7900b4fe">getClassNames</a> (std::vector&lt; std::string &gt; &amp;end_class_names) const </td></tr>
<tr class="memdesc:af35dec8c2204ab75023062ba7900b4fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the class name strings.  <a href="#af35dec8c2204ab75023062ba7900b4fe">More...</a><br /></td></tr>
<tr class="separator:af35dec8c2204ab75023062ba7900b4fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42af4c04aace79833883c6529f05303f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1classifier.html#a42af4c04aace79833883c6529f05303f">raiseNodeTemperature</a> (const double T)</td></tr>
<tr class="memdesc:a42af4c04aace79833883c6529f05303f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smooth the distributions in all of the leaf nodes using the softmax function.  <a href="#a42af4c04aace79833883c6529f05303f">More...</a><br /></td></tr>
<tr class="separator:a42af4c04aace79833883c6529f05303f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcanopy_1_1random_forest_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcanopy_1_1random_forest_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcanopy_1_1random_forest_base.html">canopy::randomForestBase&lt; classifier&lt; TNumParams &gt;, int, discreteDistribution, discreteDistribution, TNumParams &gt;</a></td></tr>
<tr class="memitem:a514c0a85f7b671a43a85a0735931f1f8 inherit pub_methods_classcanopy_1_1random_forest_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><b>randomForestBase</b> (const int num_trees, const int num_levels)</td></tr>
<tr class="memdesc:a514c0a85f7b671a43a85a0735931f1f8 inherit pub_methods_classcanopy_1_1random_forest_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full constructor.  <a href="#a514c0a85f7b671a43a85a0735931f1f8">More...</a><br /></td></tr>
<tr class="separator:a514c0a85f7b671a43a85a0735931f1f8 inherit pub_methods_classcanopy_1_1random_forest_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd7e5ec068f3dfe3d407693c9b65ae3 inherit pub_methods_classcanopy_1_1random_forest_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><b>readFromFile</b> (const std::string filename, const int trees_used=-1, const int max_depth_used=-1)</td></tr>
<tr class="memdesc:a7bd7e5ec068f3dfe3d407693c9b65ae3 inherit pub_methods_classcanopy_1_1random_forest_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a pre-trained model in from a file.  <a href="#a7bd7e5ec068f3dfe3d407693c9b65ae3">More...</a><br /></td></tr>
<tr class="separator:a7bd7e5ec068f3dfe3d407693c9b65ae3 inherit pub_methods_classcanopy_1_1random_forest_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677e06d4acfdb2e0fdffc8e2971a66df inherit pub_methods_classcanopy_1_1random_forest_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><b>writeToFile</b> (const std::string filename) const</td></tr>
<tr class="memdesc:a677e06d4acfdb2e0fdffc8e2971a66df inherit pub_methods_classcanopy_1_1random_forest_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a trained model to a .tr file to be stored and re-used.  <a href="#a677e06d4acfdb2e0fdffc8e2971a66df">More...</a><br /></td></tr>
<tr class="separator:a677e06d4acfdb2e0fdffc8e2971a66df inherit pub_methods_classcanopy_1_1random_forest_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8925a133e8a91126d12834ff7f1b837a inherit pub_methods_classcanopy_1_1random_forest_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><b>isValid</b> () const</td></tr>
<tr class="memdesc:a8925a133e8a91126d12834ff7f1b837a inherit pub_methods_classcanopy_1_1random_forest_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a forest model is valid.  <a href="#a8925a133e8a91126d12834ff7f1b837a">More...</a><br /></td></tr>
<tr class="separator:a8925a133e8a91126d12834ff7f1b837a inherit pub_methods_classcanopy_1_1random_forest_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b9f270fe6df6f17ac6f86f1b550fb4e inherit pub_methods_classcanopy_1_1random_forest_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>setFeatureDefinitionString</b> (const std::string &amp;header_str, const std::string &amp;feat_str)</td></tr>
<tr class="memdesc:a4b9f270fe6df6f17ac6f86f1b550fb4e inherit pub_methods_classcanopy_1_1random_forest_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store arbitrary strings that define parameters of the feature extraction process.  <a href="#a4b9f270fe6df6f17ac6f86f1b550fb4e">More...</a><br /></td></tr>
<tr class="separator:a4b9f270fe6df6f17ac6f86f1b550fb4e inherit pub_methods_classcanopy_1_1random_forest_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4276dd9b1b3137cc26c3fb89494b375e inherit pub_methods_classcanopy_1_1random_forest_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>getFeatureDefinitionString</b> (std::string &amp;feat_str) const</td></tr>
<tr class="memdesc:a4276dd9b1b3137cc26c3fb89494b375e inherit pub_methods_classcanopy_1_1random_forest_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a stored feature string.  <a href="#a4276dd9b1b3137cc26c3fb89494b375e">More...</a><br /></td></tr>
<tr class="separator:a4276dd9b1b3137cc26c3fb89494b375e inherit pub_methods_classcanopy_1_1random_forest_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc82fbe49123558dd5ee597f005cb16b inherit pub_methods_classcanopy_1_1random_forest_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>train</b> (const TIdIterator first_id, const TIdIterator last_id, const TLabelIterator first_label, TFeatureFunctor &amp;&amp;feature_functor, TParameterFunctor &amp;&amp;parameter_functor, const unsigned num_param_combos_to_test, const bool bagging=true, const float bag_proportion=<a class="el" href="classcanopy_1_1random_forest_base.html#a26bb427fd3744a3a5836ca939134ed4e">C_DEFAULT_BAGGING_PROPORTION</a>, const bool <a class="el" href="classcanopy_1_1random_forest_base.html#a6dda9d0ce7c2dc57f3b747302d1492f8">fit_split_nodes</a>=true, const unsigned min_training_data=<a class="el" href="classcanopy_1_1random_forest_base.html#af9d0fefed5fe6b43bc6a13ebfe0f65c4">C_DEFAULT_MIN_TRAINING_DATA</a>)</td></tr>
<tr class="memdesc:adc82fbe49123558dd5ee597f005cb16b inherit pub_methods_classcanopy_1_1random_forest_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Train the random forest model on training data.  <a href="#adc82fbe49123558dd5ee597f005cb16b">More...</a><br /></td></tr>
<tr class="separator:adc82fbe49123558dd5ee597f005cb16b inherit pub_methods_classcanopy_1_1random_forest_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1863eb32b1ae355c52c53669dd543593 inherit pub_methods_classcanopy_1_1random_forest_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>predictDistGroupwise</b> (TIdIterator first_id, const TIdIterator last_id, TOutputIterator out_it, TFeatureFunctor &amp;&amp;feature_functor) const</td></tr>
<tr class="memdesc:a1863eb32b1ae355c52c53669dd543593 inherit pub_methods_classcanopy_1_1random_forest_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predict the output distribution for a number of IDs.  <a href="#a1863eb32b1ae355c52c53669dd543593">More...</a><br /></td></tr>
<tr class="separator:a1863eb32b1ae355c52c53669dd543593 inherit pub_methods_classcanopy_1_1random_forest_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ba77f1b521fc6992a8841294caedd1 inherit pub_methods_classcanopy_1_1random_forest_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>predictDistSingle</b> (TIdIterator first_id, const TIdIterator last_id, TOutputIterator out_it, TFeatureFunctor &amp;&amp;feature_functor) const</td></tr>
<tr class="memdesc:a99ba77f1b521fc6992a8841294caedd1 inherit pub_methods_classcanopy_1_1random_forest_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predict the output distribution for a number of IDs.  <a href="#a99ba77f1b521fc6992a8841294caedd1">More...</a><br /></td></tr>
<tr class="separator:a99ba77f1b521fc6992a8841294caedd1 inherit pub_methods_classcanopy_1_1random_forest_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5afcf70c2ce8271748f9a8fa16e8b88 inherit pub_methods_classcanopy_1_1random_forest_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>probabilityGroupwise</b> (TIdIterator first_id, const TIdIterator last_id, TLabelIterator label_it, TOutputIterator out_it, const bool single_label, TFeatureFunctor &amp;&amp;feature_functor) const</td></tr>
<tr class="memdesc:ab5afcf70c2ce8271748f9a8fa16e8b88 inherit pub_methods_classcanopy_1_1random_forest_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the probability of a certain value of the label for a set of data points.  <a href="#ab5afcf70c2ce8271748f9a8fa16e8b88">More...</a><br /></td></tr>
<tr class="separator:ab5afcf70c2ce8271748f9a8fa16e8b88 inherit pub_methods_classcanopy_1_1random_forest_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73019f5709e606a43c5898abb4db60fb inherit pub_methods_classcanopy_1_1random_forest_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>probabilitySingle</b> (TIdIterator first_id, const TIdIterator last_id, TLabelIterator label_it, TOutputIterator out_it, const bool single_label, TFeatureFunctor &amp;&amp;feature_functor) const</td></tr>
<tr class="memdesc:a73019f5709e606a43c5898abb4db60fb inherit pub_methods_classcanopy_1_1random_forest_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the probability of a certain value of the label for a set of data points.  <a href="#a73019f5709e606a43c5898abb4db60fb">More...</a><br /></td></tr>
<tr class="separator:a73019f5709e606a43c5898abb4db60fb inherit pub_methods_classcanopy_1_1random_forest_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c278b76407e71773617dceb4cb5142 inherit pub_methods_classcanopy_1_1random_forest_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>probabilityGroupwiseBase</b> (TIdIterator first_id, const TIdIterator last_id, TLabelIterator label_it, TOutputIterator out_it, const bool single_label, TBinaryFunction &amp;&amp;binary_function, TFeatureFunctor &amp;&amp;feature_functor, TPDFFunctor &amp;&amp;pdf_functor) const</td></tr>
<tr class="memdesc:a20c278b76407e71773617dceb4cb5142 inherit pub_methods_classcanopy_1_1random_forest_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generalised version of the <code><a class="el" href="classcanopy_1_1random_forest_base.html#ab5afcf70c2ce8271748f9a8fa16e8b88">probabilityGroupwise()</a></code> function that enables the creation of more general functions.  <a href="#a20c278b76407e71773617dceb4cb5142">More...</a><br /></td></tr>
<tr class="separator:a20c278b76407e71773617dceb4cb5142 inherit pub_methods_classcanopy_1_1random_forest_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6aac36bc8ce187cfae98cdbf190975 inherit pub_methods_classcanopy_1_1random_forest_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>probabilitySingleBase</b> (TIdIterator first_id, const TIdIterator last_id, TLabelIterator label_it, TOutputIterator out_it, const bool single_label, TBinaryFunction &amp;&amp;binary_function, TFeatureFunctor &amp;&amp;feature_functor, TPDFFunctor &amp;&amp;pdf_functor) const</td></tr>
<tr class="memdesc:acb6aac36bc8ce187cfae98cdbf190975 inherit pub_methods_classcanopy_1_1random_forest_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generalised version of the <code><a class="el" href="classcanopy_1_1random_forest_base.html#a73019f5709e606a43c5898abb4db60fb">probabilitySingle()</a></code> function that enables the creation of more general functions.  <a href="#acb6aac36bc8ce187cfae98cdbf190975">More...</a><br /></td></tr>
<tr class="separator:acb6aac36bc8ce187cfae98cdbf190975 inherit pub_methods_classcanopy_1_1random_forest_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:aa9ae0e92d303adfdf99783fefe0ca6cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9ae0e92d303adfdf99783fefe0ca6cc"></a>
typedef <a class="el" href="classcanopy_1_1random_forest_base.html">randomForestBase</a>&lt; <a class="el" href="classcanopy_1_1classifier.html">classifier</a>&lt; TNumParams &gt;, int, <a class="el" href="classcanopy_1_1discrete_distribution.html">discreteDistribution</a>, <a class="el" href="classcanopy_1_1discrete_distribution.html">discreteDistribution</a>, TNumParams &gt;::<a class="el" href="classcanopy_1_1classifier.html#aa9ae0e92d303adfdf99783fefe0ca6cc">scoreInternalIndexStruct</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1classifier.html#aa9ae0e92d303adfdf99783fefe0ca6cc">scoreInternalIndexStruct</a></td></tr>
<tr class="memdesc:aa9ae0e92d303adfdf99783fefe0ca6cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward the definition of the type declared in the <a class="el" href="classcanopy_1_1random_forest_base.html" title="Base class for random forests models from which all specific models are derived using CRTP...">randomForestBase</a> class. <br /></td></tr>
<tr class="separator:aa9ae0e92d303adfdf99783fefe0ca6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:acecf8532dd7f8330f822b4f2bf360492"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1classifier.html#acecf8532dd7f8330f822b4f2bf360492">initialiseNodeDist</a> (const int t, const int n)</td></tr>
<tr class="memdesc:acecf8532dd7f8330f822b4f2bf360492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a <a class="el" href="classcanopy_1_1discrete_distribution.html" title="A distribution that defines the probabilities over a number of discrete (integer-valued) class labels...">discreteDistribution</a> as a node distribution for training.  <a href="#acecf8532dd7f8330f822b4f2bf360492">More...</a><br /></td></tr>
<tr class="separator:acecf8532dd7f8330f822b4f2bf360492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f77a43f53675636768f5235cc7c314"><td class="memTemplParams" colspan="2">template&lt;class TLabelIterator &gt; </td></tr>
<tr class="memitem:ae2f77a43f53675636768f5235cc7c314"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcanopy_1_1classifier.html#ae2f77a43f53675636768f5235cc7c314">bestSplit</a> (const std::vector&lt; <a class="el" href="classcanopy_1_1classifier.html#aa9ae0e92d303adfdf99783fefe0ca6cc">scoreInternalIndexStruct</a> &gt; &amp;data_structs, const TLabelIterator first_label, const int, const int, const float initial_impurity, float &amp;info_gain, float &amp;thresh) const </td></tr>
<tr class="memdesc:ae2f77a43f53675636768f5235cc7c314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the best way to split training data using the scores of a certain feature.  <a href="#ae2f77a43f53675636768f5235cc7c314">More...</a><br /></td></tr>
<tr class="separator:ae2f77a43f53675636768f5235cc7c314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a665cb8b06adb2c94724f582554c89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1classifier.html#af6a665cb8b06adb2c94724f582554c89">printHeaderDescription</a> (std::ofstream &amp;stream) const </td></tr>
<tr class="memdesc:af6a665cb8b06adb2c94724f582554c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a string that allows a human to interpret the header information to a stream.  <a href="#af6a665cb8b06adb2c94724f582554c89">More...</a><br /></td></tr>
<tr class="separator:af6a665cb8b06adb2c94724f582554c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6bacb236a6a801f1baa2f1b903cf34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1classifier.html#add6bacb236a6a801f1baa2f1b903cf34">printHeaderData</a> (std::ofstream &amp;stream) const </td></tr>
<tr class="memdesc:add6bacb236a6a801f1baa2f1b903cf34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the header information specific to the classifier model to a stream.  <a href="#add6bacb236a6a801f1baa2f1b903cf34">More...</a><br /></td></tr>
<tr class="separator:add6bacb236a6a801f1baa2f1b903cf34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7645955482670397152c68ff0ed12f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1classifier.html#ae7645955482670397152c68ff0ed12f9">readHeader</a> (std::ifstream &amp;stream)</td></tr>
<tr class="memdesc:ae7645955482670397152c68ff0ed12f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the header information specific to the classifier model from a stream.  <a href="#ae7645955482670397152c68ff0ed12f9">More...</a><br /></td></tr>
<tr class="separator:ae7645955482670397152c68ff0ed12f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf023f14cefffbce6a36365a0540bd5"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1classifier.html#accf023f14cefffbce6a36365a0540bd5">minInfoGain</a> (const int, const int) const </td></tr>
<tr class="memdesc:accf023f14cefffbce6a36365a0540bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the information gain threshold for a given node.  <a href="#accf023f14cefffbce6a36365a0540bd5">More...</a><br /></td></tr>
<tr class="separator:accf023f14cefffbce6a36365a0540bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc43c802b581caab7ba79637b0ec6f3"><td class="memTemplParams" colspan="2">template&lt;class TLabelIterator &gt; </td></tr>
<tr class="memitem:a8fc43c802b581caab7ba79637b0ec6f3"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcanopy_1_1classifier.html#a8fc43c802b581caab7ba79637b0ec6f3">singleNodeImpurity</a> (const TLabelIterator first_label, const std::vector&lt; int &gt; &amp;nodebag, const int, const int) const </td></tr>
<tr class="memdesc:a8fc43c802b581caab7ba79637b0ec6f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the impurity of the label set in a single node.  <a href="#a8fc43c802b581caab7ba79637b0ec6f3">More...</a><br /></td></tr>
<tr class="separator:a8fc43c802b581caab7ba79637b0ec6f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2244bb41557f84a95d8a7962bcbffd6a"><td class="memTemplParams" colspan="2">template&lt;class TLabelIterator , class TIdIterator &gt; </td></tr>
<tr class="memitem:a2244bb41557f84a95d8a7962bcbffd6a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcanopy_1_1classifier.html#a2244bb41557f84a95d8a7962bcbffd6a">trainingPrecalculations</a> (const TLabelIterator first_label, const TLabelIterator last_label, const TIdIterator)</td></tr>
<tr class="memdesc:a2244bb41557f84a95d8a7962bcbffd6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preliminary calculations to perform berfore training begins.  <a href="#a2244bb41557f84a95d8a7962bcbffd6a">More...</a><br /></td></tr>
<tr class="separator:a2244bb41557f84a95d8a7962bcbffd6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ad097e958d6cdf0ce7a78015d71c17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1classifier.html#a54ad097e958d6cdf0ce7a78015d71c17">cleanupPrecalculations</a> ()</td></tr>
<tr class="memdesc:a54ad097e958d6cdf0ce7a78015d71c17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean-up of data to perform after training ends.  <a href="#a54ad097e958d6cdf0ce7a78015d71c17">More...</a><br /></td></tr>
<tr class="separator:a54ad097e958d6cdf0ce7a78015d71c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classcanopy_1_1random_forest_base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classcanopy_1_1random_forest_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classcanopy_1_1random_forest_base.html">canopy::randomForestBase&lt; classifier&lt; TNumParams &gt;, int, discreteDistribution, discreteDistribution, TNumParams &gt;</a></td></tr>
<tr class="memitem:ab98245bd4f015b9e6652f6744d0690ec inherit pro_methods_classcanopy_1_1random_forest_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>findLeavesGroupwise</b> (TIdIterator first_id, const TIdIterator last_id, const int treenum, std::vector&lt; const <a class="el" href="classcanopy_1_1discrete_distribution.html">discreteDistribution</a> * &gt; &amp;leaves, TFeatureFunctor &amp;&amp;feature_functor) const</td></tr>
<tr class="memdesc:ab98245bd4f015b9e6652f6744d0690ec inherit pro_methods_classcanopy_1_1random_forest_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to query a single tree model with a set of data points and store a pointer to the leaf distribution that each reaches.  <a href="#ab98245bd4f015b9e6652f6744d0690ec">More...</a><br /></td></tr>
<tr class="separator:ab98245bd4f015b9e6652f6744d0690ec inherit pro_methods_classcanopy_1_1random_forest_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af809ee6c8d2db1014f836a4c4f7a77c4 inherit pro_methods_classcanopy_1_1random_forest_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcanopy_1_1discrete_distribution.html">discreteDistribution</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>findLeafSingle</b> (const TId id, const int treenum, TFeatureFunctor &amp;&amp;feature_functor) const</td></tr>
<tr class="memdesc:af809ee6c8d2db1014f836a4c4f7a77c4 inherit pro_methods_classcanopy_1_1random_forest_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to query a single tree model with a single data point and return a pointer to the leaf distribution that it reaches.  <a href="#af809ee6c8d2db1014f836a4c4f7a77c4">More...</a><br /></td></tr>
<tr class="separator:af809ee6c8d2db1014f836a4c4f7a77c4 inherit pro_methods_classcanopy_1_1random_forest_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a69fd43fe63d4654ded884cf7419f7c9e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69fd43fe63d4654ded884cf7419f7c9e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1classifier.html#a69fd43fe63d4654ded884cf7419f7c9e">n_classes</a></td></tr>
<tr class="memdesc:a69fd43fe63d4654ded884cf7419f7c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of classes in the discrete label space. <br /></td></tr>
<tr class="separator:a69fd43fe63d4654ded884cf7419f7c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d3554b08d3bc036de6a1f1fa7d4f35"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49d3554b08d3bc036de6a1f1fa7d4f35"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1classifier.html#a49d3554b08d3bc036de6a1f1fa7d4f35">class_names</a></td></tr>
<tr class="memdesc:a49d3554b08d3bc036de6a1f1fa7d4f35"><td class="mdescLeft">&#160;</td><td class="mdescRight">The names of the classes. <br /></td></tr>
<tr class="separator:a49d3554b08d3bc036de6a1f1fa7d4f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76be4da13d92bd6dcdea6aeaa53db61"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa76be4da13d92bd6dcdea6aeaa53db61"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1classifier.html#aa76be4da13d92bd6dcdea6aeaa53db61">xlogx_precalc</a></td></tr>
<tr class="memdesc:aa76be4da13d92bd6dcdea6aeaa53db61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for storing temporary precalculations of x*log(x) values during training. <br /></td></tr>
<tr class="separator:aa76be4da13d92bd6dcdea6aeaa53db61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0a2fdbf404200678d8022342368f2b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b0a2fdbf404200678d8022342368f2b"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1classifier.html#a3b0a2fdbf404200678d8022342368f2b">min_info_gain</a></td></tr>
<tr class="memdesc:a3b0a2fdbf404200678d8022342368f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">If during training, the best information gain at a node goes below this threshold, a lead node is declared. <br /></td></tr>
<tr class="separator:a3b0a2fdbf404200678d8022342368f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classcanopy_1_1random_forest_base"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classcanopy_1_1random_forest_base')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classcanopy_1_1random_forest_base.html">canopy::randomForestBase&lt; classifier&lt; TNumParams &gt;, int, discreteDistribution, discreteDistribution, TNumParams &gt;</a></td></tr>
<tr class="memitem:af2b2ae739f4a2fd9dd99baf4027dea45 inherit pro_attribs_classcanopy_1_1random_forest_base"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2b2ae739f4a2fd9dd99baf4027dea45"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#af2b2ae739f4a2fd9dd99baf4027dea45">n_trees</a></td></tr>
<tr class="memdesc:af2b2ae739f4a2fd9dd99baf4027dea45 inherit pro_attribs_classcanopy_1_1random_forest_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of trees in the forest. <br /></td></tr>
<tr class="separator:af2b2ae739f4a2fd9dd99baf4027dea45 inherit pro_attribs_classcanopy_1_1random_forest_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3d1d8b770bb02dfccc63948ce27322 inherit pro_attribs_classcanopy_1_1random_forest_base"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe3d1d8b770bb02dfccc63948ce27322"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#abe3d1d8b770bb02dfccc63948ce27322">n_levels</a></td></tr>
<tr class="memdesc:abe3d1d8b770bb02dfccc63948ce27322 inherit pro_attribs_classcanopy_1_1random_forest_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of levels in each tree. <br /></td></tr>
<tr class="separator:abe3d1d8b770bb02dfccc63948ce27322 inherit pro_attribs_classcanopy_1_1random_forest_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d370db45fce2b295071decedbb93b1 inherit pro_attribs_classcanopy_1_1random_forest_base"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91d370db45fce2b295071decedbb93b1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#a91d370db45fce2b295071decedbb93b1">n_nodes</a></td></tr>
<tr class="memdesc:a91d370db45fce2b295071decedbb93b1 inherit pro_attribs_classcanopy_1_1random_forest_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of nodes in each tree. <br /></td></tr>
<tr class="separator:a91d370db45fce2b295071decedbb93b1 inherit pro_attribs_classcanopy_1_1random_forest_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba612654496367659b1951694430600 inherit pro_attribs_classcanopy_1_1random_forest_base"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ba612654496367659b1951694430600"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#a7ba612654496367659b1951694430600">valid</a></td></tr>
<tr class="memdesc:a7ba612654496367659b1951694430600 inherit pro_attribs_classcanopy_1_1random_forest_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the forest model is currently valid and usable for predictions (true = valid) <br /></td></tr>
<tr class="separator:a7ba612654496367659b1951694430600 inherit pro_attribs_classcanopy_1_1random_forest_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dda9d0ce7c2dc57f3b747302d1492f8 inherit pro_attribs_classcanopy_1_1random_forest_base"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6dda9d0ce7c2dc57f3b747302d1492f8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#a6dda9d0ce7c2dc57f3b747302d1492f8">fit_split_nodes</a></td></tr>
<tr class="memdesc:a6dda9d0ce7c2dc57f3b747302d1492f8 inherit pro_attribs_classcanopy_1_1random_forest_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a node distribution is fitted to all nodes (true) or just the leaf nodes (false) <br /></td></tr>
<tr class="separator:a6dda9d0ce7c2dc57f3b747302d1492f8 inherit pro_attribs_classcanopy_1_1random_forest_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f902b8befa1467c4580d41fb7e7376 inherit pro_attribs_classcanopy_1_1random_forest_base"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13f902b8befa1467c4580d41fb7e7376"></a>
std::vector&lt; tree &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#a13f902b8befa1467c4580d41fb7e7376">forest</a></td></tr>
<tr class="memdesc:a13f902b8befa1467c4580d41fb7e7376 inherit pro_attribs_classcanopy_1_1random_forest_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of tree models. <br /></td></tr>
<tr class="separator:a13f902b8befa1467c4580d41fb7e7376 inherit pro_attribs_classcanopy_1_1random_forest_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1762732027985afe09ab09c722be1e71 inherit pro_attribs_classcanopy_1_1random_forest_base"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1762732027985afe09ab09c722be1e71"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#a1762732027985afe09ab09c722be1e71">feature_header</a></td></tr>
<tr class="memdesc:a1762732027985afe09ab09c722be1e71 inherit pro_attribs_classcanopy_1_1random_forest_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">String describing the content of the feature string. <br /></td></tr>
<tr class="separator:a1762732027985afe09ab09c722be1e71 inherit pro_attribs_classcanopy_1_1random_forest_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc500e6049e65eadeaa97f3d6a47466 inherit pro_attribs_classcanopy_1_1random_forest_base"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2cc500e6049e65eadeaa97f3d6a47466"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#a2cc500e6049e65eadeaa97f3d6a47466">feature_string</a></td></tr>
<tr class="memdesc:a2cc500e6049e65eadeaa97f3d6a47466 inherit pro_attribs_classcanopy_1_1random_forest_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arbitrary string describing the feature extraction process. <br /></td></tr>
<tr class="separator:a2cc500e6049e65eadeaa97f3d6a47466 inherit pro_attribs_classcanopy_1_1random_forest_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49016a44f66b1b3e30683ec3dfaa75d5 inherit pro_attribs_classcanopy_1_1random_forest_base"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49016a44f66b1b3e30683ec3dfaa75d5"></a>
std::default_random_engine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#a49016a44f66b1b3e30683ec3dfaa75d5">rand_engine</a></td></tr>
<tr class="memdesc:a49016a44f66b1b3e30683ec3dfaa75d5 inherit pro_attribs_classcanopy_1_1random_forest_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random engine for generating random numbers during training, may also be used by derived classes. <br /></td></tr>
<tr class="separator:a49016a44f66b1b3e30683ec3dfaa75d5 inherit pro_attribs_classcanopy_1_1random_forest_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc3d5ea8b9b285fb6cf73b036dca7e4 inherit pro_attribs_classcanopy_1_1random_forest_base"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9bc3d5ea8b9b285fb6cf73b036dca7e4"></a>
std::uniform_int_distribution&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#a9bc3d5ea8b9b285fb6cf73b036dca7e4">uni_dist</a></td></tr>
<tr class="memdesc:a9bc3d5ea8b9b285fb6cf73b036dca7e4 inherit pro_attribs_classcanopy_1_1random_forest_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">For generating random integers during traning, may also be used derived classes. <br /></td></tr>
<tr class="separator:a9bc3d5ea8b9b285fb6cf73b036dca7e4 inherit pro_attribs_classcanopy_1_1random_forest_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a4d7d06e0316f7ceca7007c6f26dadc0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d7d06e0316f7ceca7007c6f26dadc0f"></a>
static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1classifier.html#a4d7d06e0316f7ceca7007c6f26dadc0f">C_DEFAULT_MIN_INFO_GAIN</a> = 0.05</td></tr>
<tr class="memdesc:a4d7d06e0316f7ceca7007c6f26dadc0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default value for the information gain threshold. <br /></td></tr>
<tr class="separator:a4d7d06e0316f7ceca7007c6f26dadc0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classcanopy_1_1random_forest_base"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classcanopy_1_1random_forest_base')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classcanopy_1_1random_forest_base.html">canopy::randomForestBase&lt; classifier&lt; TNumParams &gt;, int, discreteDistribution, discreteDistribution, TNumParams &gt;</a></td></tr>
<tr class="memitem:af9d0fefed5fe6b43bc6a13ebfe0f65c4 inherit pro_static_attribs_classcanopy_1_1random_forest_base"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9d0fefed5fe6b43bc6a13ebfe0f65c4"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#af9d0fefed5fe6b43bc6a13ebfe0f65c4">C_DEFAULT_MIN_TRAINING_DATA</a></td></tr>
<tr class="memdesc:af9d0fefed5fe6b43bc6a13ebfe0f65c4 inherit pro_static_attribs_classcanopy_1_1random_forest_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default value for the minimum number of traning data points in a node before a leaf is declared. <br /></td></tr>
<tr class="separator:af9d0fefed5fe6b43bc6a13ebfe0f65c4 inherit pro_static_attribs_classcanopy_1_1random_forest_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26bb427fd3744a3a5836ca939134ed4e inherit pro_static_attribs_classcanopy_1_1random_forest_base"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26bb427fd3744a3a5836ca939134ed4e"></a>
static constexpr float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#a26bb427fd3744a3a5836ca939134ed4e">C_DEFAULT_BAGGING_PROPORTION</a></td></tr>
<tr class="memdesc:a26bb427fd3744a3a5836ca939134ed4e inherit pro_static_attribs_classcanopy_1_1random_forest_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default value for the proportion of the traning set used to train each tree. <br /></td></tr>
<tr class="separator:a26bb427fd3744a3a5836ca939134ed4e inherit pro_static_attribs_classcanopy_1_1random_forest_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_static_methods_classcanopy_1_1random_forest_base"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classcanopy_1_1random_forest_base')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classcanopy_1_1random_forest_base.html">canopy::randomForestBase&lt; classifier&lt; TNumParams &gt;, int, discreteDistribution, discreteDistribution, TNumParams &gt;</a></td></tr>
<tr class="memitem:a8fcbaa753118df056efb4894279d8d13 inherit pro_static_methods_classcanopy_1_1random_forest_base"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><b>fastDiscreteEntropy</b> (const std::vector&lt; int &gt; &amp;internal_index, const int n_labels, const TLabelIterator first_label, const std::vector&lt; double &gt; &amp;xlogx_precalc)</td></tr>
<tr class="memdesc:a8fcbaa753118df056efb4894279d8d13 inherit pro_static_methods_classcanopy_1_1random_forest_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the entropy of the discrete labels of a set of data points using an efficient method.  <a href="#a8fcbaa753118df056efb4894279d8d13">More...</a><br /></td></tr>
<tr class="separator:a8fcbaa753118df056efb4894279d8d13 inherit pro_static_methods_classcanopy_1_1random_forest_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c035bc917583018a0ce3cddf4a720c inherit pro_static_methods_classcanopy_1_1random_forest_base"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><b>fastDiscreteEntropySplit</b> (const std::vector&lt; scoreInternalIndexStruct &gt; &amp;data_structs, const int n_labels, const TLabelIterator first_label, const std::vector&lt; double &gt; &amp;xlogx_precalc, double &amp;best_split_impurity, float &amp;thresh)</td></tr>
<tr class="memdesc:ad8c035bc917583018a0ce3cddf4a720c inherit pro_static_methods_classcanopy_1_1random_forest_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the split in a set of training data that results in the best information gain for discrete labels.  <a href="#ad8c035bc917583018a0ce3cddf4a720c">More...</a><br /></td></tr>
<tr class="separator:ad8c035bc917583018a0ce3cddf4a720c inherit pro_static_methods_classcanopy_1_1random_forest_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677388c9a3916597d389b8189c39a9f8 inherit pro_static_methods_classcanopy_1_1random_forest_base"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>preCalculateXlogX</b> (const int N)</td></tr>
<tr class="memdesc:a677388c9a3916597d389b8189c39a9f8 inherit pro_static_methods_classcanopy_1_1random_forest_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate an array of x*log(x) for integer x.  <a href="#a677388c9a3916597d389b8189c39a9f8">More...</a><br /></td></tr>
<tr class="separator:a677388c9a3916597d389b8189c39a9f8 inherit pro_static_methods_classcanopy_1_1random_forest_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;unsigned TNumParams&gt;<br />
class canopy::classifier&lt; TNumParams &gt;</h3>

<p>Implements a random forest classifier model to predict a discrete output label. </p>
<p>This class uses the <a class="el" href="classcanopy_1_1discrete_distribution.html" title="A distribution that defines the probabilities over a number of discrete (integer-valued) class labels...">discreteDistribution</a> as both the output distribution and the node distribution, and int as the type of label to predict.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TNumParams</td><td>The number of parameters used by the features callback functor. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a17e8bdd1d3ed477a375a4eefc6c2432b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned TNumParams&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcanopy_1_1classifier.html">canopy::classifier</a>&lt; TNumParams &gt;::<a class="el" href="classcanopy_1_1classifier.html">classifier</a> </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_classes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_trees</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_levels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>info_gain_tresh</em> = <code><a class="el" href="classcanopy_1_1classifier.html#a4d7d06e0316f7ceca7007c6f26dadc0f">C_DEFAULT_MIN_INFO_GAIN</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Full constructor. </p>
<p>Creates a full forest with a specified number of trees and levels, ready to be trained. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_classes</td><td>Number of discrete classes in the label space. The labels are assumed to run from 0 to num_classes-1 inclusive. </td></tr>
    <tr><td class="paramname">num_trees</td><td>The number of decision trees in the forest </td></tr>
    <tr><td class="paramname">num_levels</td><td>The maximum depth of any node in the trees </td></tr>
    <tr><td class="paramname">info_gain_tresh</td><td>The information gain threshold to use when training the model. Nodes where the best split is found to result in an information gain value less than this threshold are made into leaf nodes. Default: C_DEFAULT_MIN_INFO_GAIN </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a120e1aa5231540f18a6d58124a77ab0b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned TNumParams&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcanopy_1_1classifier.html">canopy::classifier</a>&lt; TNumParams &gt;::<a class="el" href="classcanopy_1_1classifier.html">classifier</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Note that an object initialised in this way should not be trained, but may be used to read in a pre-trained model using <code><a class="el" href="classcanopy_1_1random_forest_base.html#a7bd7e5ec068f3dfe3d407693c9b65ae3">readFromFile()</a></code> </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ae2f77a43f53675636768f5235cc7c314"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned TNumParams&gt; </div>
<div class="memtemplate">
template&lt;class TLabelIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcanopy_1_1classifier.html">canopy::classifier</a>&lt; TNumParams &gt;::bestSplit </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcanopy_1_1classifier.html#aa9ae0e92d303adfdf99783fefe0ca6cc">scoreInternalIndexStruct</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_structs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TLabelIterator&#160;</td>
          <td class="paramname"><em>first_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>initial_impurity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>info_gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>thresh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the best way to split training data using the scores of a certain feature. </p>
<p>This method takes a set of training data points and their scores resulting from some feature, and calculates the best score threshold that may be used to split the data into two partitions. The best split is the one that results in the greatest information gain in the child nodes, which in this case is based on the discrete entropy.</p>
<p>This method is called automatically by the base class.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TLabelIterator</td><td>Type of the iterator used to access the discrete labels. Must be a random access iterator that dereferences to an integral data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_structs</td><td>A vector in which each element is a structure containing the internal id (.id) and score (.score) for the current feature of the training data points. The vector is assumed to be sorted according to the score field in ascending order. </td></tr>
    <tr><td class="paramname">first_label</td><td>Iterator to the labels for which the entropy is to be calculated. The labels should be located at the offsets from this iterator given by the IDs of elements of the data_structs vector. I.e. <div class="fragment"><div class="line">first_label[data_structs[0].id]</div><div class="line">first_label[data_structs[1].id]</div></div><!-- fragment --> etc. </td></tr>
    <tr><td class="paramname">-</td><td>The third parameter is unused but required for compatibility with <a class="el" href="classcanopy_1_1random_forest_base.html" title="Base class for random forests models from which all specific models are derived using CRTP...">randomForestBase</a> </td></tr>
    <tr><td class="paramname">-</td><td>The fourth parameter is unused but required for compatibility with <a class="el" href="classcanopy_1_1random_forest_base.html" title="Base class for random forests models from which all specific models are derived using CRTP...">randomForestBase</a> </td></tr>
    <tr><td class="paramname">initial_impurity</td><td>The initial impurity of the node before the split. This must be calculated with <code><a class="el" href="classcanopy_1_1classifier.html#a8fc43c802b581caab7ba79637b0ec6f3" title="Calculate the impurity of the label set in a single node. ">singleNodeImpurity()</a></code> and passed in </td></tr>
    <tr><td class="paramname">info_gain</td><td>The information gain associated with the best split (i.e. the maximum achievable information gain with this feature) is returned by reference in this parameter </td></tr>
    <tr><td class="paramname">thresh</td><td>The threshold value of the feature score corresponding to tbe best split is returned by reference in this parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a54ad097e958d6cdf0ce7a78015d71c17"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned TNumParams&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcanopy_1_1classifier.html">canopy::classifier</a>&lt; TNumParams &gt;::cleanupPrecalculations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clean-up of data to perform after training ends. </p>
<p>In this case this clears the pre-calculated array created by <code><a class="el" href="classcanopy_1_1classifier.html#a2244bb41557f84a95d8a7962bcbffd6a" title="Preliminary calculations to perform berfore training begins. ">trainingPrecalculations()</a></code> </p>
<p>This method is called automatically by the base class. </p>

</div>
</div>
<a class="anchor" id="af35dec8c2204ab75023062ba7900b4fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned TNumParams&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcanopy_1_1classifier.html">canopy::classifier</a>&lt; TNumParams &gt;::getClassNames </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>class_names</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the class name strings. </p>
<p>Retrieve a previously stored set of class names.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">class_names</td><td>The class names are returned by reference in this vector. If none have been set, an empty vector is returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af3f1330730c050bf69ae1f3835df0bff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned TNumParams&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classcanopy_1_1classifier.html">canopy::classifier</a>&lt; TNumParams &gt;::getNumberClasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of classes in the discrete label space of the model. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of classes </dd></dl>

</div>
</div>
<a class="anchor" id="acecf8532dd7f8330f822b4f2bf360492"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned TNumParams&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcanopy_1_1classifier.html">canopy::classifier</a>&lt; TNumParams &gt;::initialiseNodeDist </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialise a <a class="el" href="classcanopy_1_1discrete_distribution.html" title="A distribution that defines the probabilities over a number of discrete (integer-valued) class labels...">discreteDistribution</a> as a node distribution for training. </p>
<p>This method is called automatically by the base class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Index of the tree in which the distribution is to be initialised </td></tr>
    <tr><td class="paramname">n</td><td>Index of the node to be initialised within its tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="accf023f14cefffbce6a36365a0540bd5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned TNumParams&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classcanopy_1_1classifier.html">canopy::classifier</a>&lt; TNumParams &gt;::minInfoGain </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the information gain threshold for a given node. </p>
<p>In this case, this is a fixed value for all nodes. This method is called automatically by the base class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">-</td><td>The first parameter is unused but required for compatibility with <code><a class="el" href="classcanopy_1_1random_forest_base.html" title="Base class for random forests models from which all specific models are derived using CRTP...">randomForestBase</a></code> </td></tr>
    <tr><td class="paramname">-</td><td>The second parameter is unused but required for compatibility with <code><a class="el" href="classcanopy_1_1random_forest_base.html" title="Base class for random forests models from which all specific models are derived using CRTP...">randomForestBase</a></code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The threshold value for information gain. If a split results in a information gain less than this value, the node should be made a leaf instead. </dd></dl>

</div>
</div>
<a class="anchor" id="add6bacb236a6a801f1baa2f1b903cf34"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned TNumParams&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcanopy_1_1classifier.html">canopy::classifier</a>&lt; TNumParams &gt;::printHeaderData </td>
          <td>(</td>
          <td class="paramtype">std::ofstream &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the header information specific to the classifier model to a stream. </p>
<p>This prints out the number of classes and the class names to the stream.</p>
<p>This method is called automatically by the base class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream to which the header is printed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af6a665cb8b06adb2c94724f582554c89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned TNumParams&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcanopy_1_1classifier.html">canopy::classifier</a>&lt; TNumParams &gt;::printHeaderDescription </td>
          <td>(</td>
          <td class="paramtype">std::ofstream &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints a string that allows a human to interpret the header information to a stream. </p>
<p>This method is called automatically by the base class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream to which the header description is printed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a42af4c04aace79833883c6529f05303f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned TNumParams&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcanopy_1_1classifier.html">canopy::classifier</a>&lt; TNumParams &gt;::raiseNodeTemperature </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>T</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smooth the distributions in all of the leaf nodes using the softmax function. </p>
<p>This alters the probability distributions by replacing the probability of class \( i \) according to </p><p class="formulaDsp">
\[ p_i \leftarrow \frac{ e^{\frac{p_i}{T}}}{\sum_{j=1}^N {e^\frac{p_j}{T}} } \]
</p>
<p>where \( N \) is the number of classes and \( T \) is a temperature parameter. This has the effect of regularising the distributions, reducing the certainty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The temperature parameter. The higher the temperature, the more the certainty is reduced. T must be a strictly positive number, otherwise this function will have no effect. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae7645955482670397152c68ff0ed12f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned TNumParams&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcanopy_1_1classifier.html">canopy::classifier</a>&lt; TNumParams &gt;::readHeader </td>
          <td>(</td>
          <td class="paramtype">std::ifstream &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the header information specific to the classifier model from a stream. </p>
<p>This reads in the number of classes and the class names from the stream.</p>
<p>This method is called automatically by the base class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream from which the header information is read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2058bb3b63989760a929d54846356314"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned TNumParams&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcanopy_1_1classifier.html">canopy::classifier</a>&lt; TNumParams &gt;::setClassNames </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_class_names</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the class name strings. </p>
<p>These will be stored within the model (including when written to file) and may be retrieved at a later date, however they do not affect the operation of the model in any way and are entirely optional.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_class_names</td><td>Vector with each element containing the name of one class </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8fc43c802b581caab7ba79637b0ec6f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned TNumParams&gt; </div>
<div class="memtemplate">
template&lt;class TLabelIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classcanopy_1_1classifier.html">canopy::classifier</a>&lt; TNumParams &gt;::singleNodeImpurity </td>
          <td>(</td>
          <td class="paramtype">const TLabelIterator&#160;</td>
          <td class="paramname"><em>first_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodebag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the impurity of the label set in a single node. </p>
<p>This method takes the labels (discrete class labels) of a set of training data points and calculates the impurity of that set. In this case, this is based on the discrete entropy of the set.</p>
<p>This method is called automatically by the base class. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TLabelIterator</td><td>Type of the iterator used to access the discrete labels. Must be a random access iterator that dereferences to an integral data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_label</td><td>Iterator to the labels for which the entropy is to be calculated. The labels should be located at the offsets from this iterator given by the elements of the nodebag vector. I.e. <div class="fragment"><div class="line">first_label[nodebag[0]]</div><div class="line">first_label[nodebag[1]]</div></div><!-- fragment --> etc. </td></tr>
    <tr><td class="paramname">nodebag</td><td>Vector containing the internal training indices of the data points. These are the indices through which the labels may be accessed in first_label </td></tr>
    <tr><td class="paramname">-</td><td>The third parameter is unused but required for compatibility with <a class="el" href="classcanopy_1_1random_forest_base.html" title="Base class for random forests models from which all specific models are derived using CRTP...">randomForestBase</a> </td></tr>
    <tr><td class="paramname">-</td><td>The fourth parameter is unused but required for compatibility with <a class="el" href="classcanopy_1_1random_forest_base.html" title="Base class for random forests models from which all specific models are derived using CRTP...">randomForestBase</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2244bb41557f84a95d8a7962bcbffd6a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned TNumParams&gt; </div>
<div class="memtemplate">
template&lt;class TLabelIterator , class TIdIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcanopy_1_1classifier.html">canopy::classifier</a>&lt; TNumParams &gt;::trainingPrecalculations </td>
          <td>(</td>
          <td class="paramtype">const TLabelIterator&#160;</td>
          <td class="paramname"><em>first_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TLabelIterator&#160;</td>
          <td class="paramname"><em>last_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIdIterator&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Preliminary calculations to perform berfore training begins. </p>
<p>In this case this pre-calculates an array of values of x*log(x) to speed up entropy calculations.</p>
<p>This method is called automatically by the base class.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TLabelIterator</td><td>Type of the iterator used to access the training labels Must be a random access iterator than dereferences to an integral data type. </td></tr>
    <tr><td class="paramname">TIdIterator</td><td>Type of the iterator used to access the IDs of the training data. The IDs are unused by required for compatibility with <a class="el" href="classcanopy_1_1random_forest_base.html" title="Base class for random forests models from which all specific models are derived using CRTP...">randomForestBase</a> .</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_label</td><td>Iterator to the first label in the training set </td></tr>
    <tr><td class="paramname">last_label</td><td>Iterator to the last label in the training set </td></tr>
    <tr><td class="paramname">-</td><td>The third parameter is unused but required for compatibility with <a class="el" href="classcanopy_1_1random_forest_base.html" title="Base class for random forests models from which all specific models are derived using CRTP...">randomForestBase</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/local/ball3996/dphil/github/canopy/include/canopy/classifier/<a class="el" href="classifier_8hpp_source.html">classifier.hpp</a></li>
<li>/local/ball3996/dphil/github/canopy/include/canopy/classifier/<a class="el" href="classifier_8tpp.html">classifier.tpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
