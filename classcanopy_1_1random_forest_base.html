<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Canopy: canopy::randomForestBase&lt; TDerived, TLabel, TNodeDist, TOutputDist, TNumParams &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Canopy
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">The header-only random forests library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecanopy.html">canopy</a></li><li class="navelem"><a class="el" href="classcanopy_1_1random_forest_base.html">randomForestBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classcanopy_1_1random_forest_base-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">canopy::randomForestBase&lt; TDerived, TLabel, TNodeDist, TOutputDist, TNumParams &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class for random forests models from which all specific models are derived using CRTP.  
 <a href="classcanopy_1_1random_forest_base.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="random_forest_base_8hpp_source.html">randomForestBase.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base_1_1derived_proxy.html">derivedProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the derived class.  <a href="classcanopy_1_1random_forest_base_1_1derived_proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcanopy_1_1random_forest_base_1_1node.html">node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node structure - represents one node in a tree.  <a href="structcanopy_1_1random_forest_base_1_1node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcanopy_1_1random_forest_base_1_1score_internal_index_struct.html">scoreInternalIndexStruct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for holding information about a data sample and its feature score.  <a href="structcanopy_1_1random_forest_base_1_1score_internal_index_struct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcanopy_1_1random_forest_base_1_1tree.html">tree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tree structure - represents a single tree.  <a href="structcanopy_1_1random_forest_base_1_1tree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a70c06b08b674b7cad75a78936c35638a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#a70c06b08b674b7cad75a78936c35638a">randomForestBase</a> ()</td></tr>
<tr class="memdesc:a70c06b08b674b7cad75a78936c35638a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a70c06b08b674b7cad75a78936c35638a">More...</a><br /></td></tr>
<tr class="separator:a70c06b08b674b7cad75a78936c35638a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514c0a85f7b671a43a85a0735931f1f8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#a514c0a85f7b671a43a85a0735931f1f8">randomForestBase</a> (const int num_trees, const int num_levels)</td></tr>
<tr class="memdesc:a514c0a85f7b671a43a85a0735931f1f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full constructor.  <a href="#a514c0a85f7b671a43a85a0735931f1f8">More...</a><br /></td></tr>
<tr class="separator:a514c0a85f7b671a43a85a0735931f1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd7e5ec068f3dfe3d407693c9b65ae3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#a7bd7e5ec068f3dfe3d407693c9b65ae3">readFromFile</a> (const std::string filename, const int trees_used=-1, const int max_depth_used=-1)</td></tr>
<tr class="memdesc:a7bd7e5ec068f3dfe3d407693c9b65ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a pre-trained model in from a file.  <a href="#a7bd7e5ec068f3dfe3d407693c9b65ae3">More...</a><br /></td></tr>
<tr class="separator:a7bd7e5ec068f3dfe3d407693c9b65ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677e06d4acfdb2e0fdffc8e2971a66df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#a677e06d4acfdb2e0fdffc8e2971a66df">writeToFile</a> (const std::string filename) const </td></tr>
<tr class="memdesc:a677e06d4acfdb2e0fdffc8e2971a66df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a trained model to a .tr file to be stored and re-used.  <a href="#a677e06d4acfdb2e0fdffc8e2971a66df">More...</a><br /></td></tr>
<tr class="separator:a677e06d4acfdb2e0fdffc8e2971a66df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8925a133e8a91126d12834ff7f1b837a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#a8925a133e8a91126d12834ff7f1b837a">isValid</a> () const </td></tr>
<tr class="memdesc:a8925a133e8a91126d12834ff7f1b837a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a forest model is valid.  <a href="#a8925a133e8a91126d12834ff7f1b837a">More...</a><br /></td></tr>
<tr class="separator:a8925a133e8a91126d12834ff7f1b837a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b9f270fe6df6f17ac6f86f1b550fb4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#a4b9f270fe6df6f17ac6f86f1b550fb4e">setFeatureDefinitionString</a> (const std::string &amp;header_str, const std::string &amp;feat_str)</td></tr>
<tr class="memdesc:a4b9f270fe6df6f17ac6f86f1b550fb4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store arbitrary strings that define parameters of the feature extraction process.  <a href="#a4b9f270fe6df6f17ac6f86f1b550fb4e">More...</a><br /></td></tr>
<tr class="separator:a4b9f270fe6df6f17ac6f86f1b550fb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4276dd9b1b3137cc26c3fb89494b375e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#a4276dd9b1b3137cc26c3fb89494b375e">getFeatureDefinitionString</a> (std::string &amp;feat_str) const </td></tr>
<tr class="memdesc:a4276dd9b1b3137cc26c3fb89494b375e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a stored feature string.  <a href="#a4276dd9b1b3137cc26c3fb89494b375e">More...</a><br /></td></tr>
<tr class="separator:a4276dd9b1b3137cc26c3fb89494b375e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc82fbe49123558dd5ee597f005cb16b"><td class="memTemplParams" colspan="2">template&lt;class TIdIterator , class TLabelIterator , class TFeatureFunctor , class TParameterFunctor &gt; </td></tr>
<tr class="memitem:adc82fbe49123558dd5ee597f005cb16b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#adc82fbe49123558dd5ee597f005cb16b">train</a> (const TIdIterator first_id, const TIdIterator last_id, const TLabelIterator first_label, TFeatureFunctor &amp;&amp;feature_functor, TParameterFunctor &amp;&amp;parameter_functor, const unsigned num_param_combos_to_test, const bool bagging=true, const float bag_proportion=<a class="el" href="classcanopy_1_1random_forest_base.html#a26bb427fd3744a3a5836ca939134ed4e">C_DEFAULT_BAGGING_PROPORTION</a>, const bool <a class="el" href="classcanopy_1_1random_forest_base.html#a6dda9d0ce7c2dc57f3b747302d1492f8">fit_split_nodes</a>=true, const unsigned min_training_data=<a class="el" href="classcanopy_1_1random_forest_base.html#af9d0fefed5fe6b43bc6a13ebfe0f65c4">C_DEFAULT_MIN_TRAINING_DATA</a>)</td></tr>
<tr class="memdesc:adc82fbe49123558dd5ee597f005cb16b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Train the random forest model on training data.  <a href="#adc82fbe49123558dd5ee597f005cb16b">More...</a><br /></td></tr>
<tr class="separator:adc82fbe49123558dd5ee597f005cb16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1863eb32b1ae355c52c53669dd543593"><td class="memTemplParams" colspan="2">template&lt;class TIdIterator , class TOutputIterator , class TFeatureFunctor &gt; </td></tr>
<tr class="memitem:a1863eb32b1ae355c52c53669dd543593"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#a1863eb32b1ae355c52c53669dd543593">predictDistGroupwise</a> (TIdIterator first_id, const TIdIterator last_id, TOutputIterator out_it, TFeatureFunctor &amp;&amp;feature_functor) const </td></tr>
<tr class="memdesc:a1863eb32b1ae355c52c53669dd543593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predict the output distribution for a number of IDs.  <a href="#a1863eb32b1ae355c52c53669dd543593">More...</a><br /></td></tr>
<tr class="separator:a1863eb32b1ae355c52c53669dd543593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ba77f1b521fc6992a8841294caedd1"><td class="memTemplParams" colspan="2">template&lt;class TIdIterator , class TOutputIterator , class TFeatureFunctor &gt; </td></tr>
<tr class="memitem:a99ba77f1b521fc6992a8841294caedd1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#a99ba77f1b521fc6992a8841294caedd1">predictDistSingle</a> (TIdIterator first_id, const TIdIterator last_id, TOutputIterator out_it, TFeatureFunctor &amp;&amp;feature_functor) const </td></tr>
<tr class="memdesc:a99ba77f1b521fc6992a8841294caedd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predict the output distribution for a number of IDs.  <a href="#a99ba77f1b521fc6992a8841294caedd1">More...</a><br /></td></tr>
<tr class="separator:a99ba77f1b521fc6992a8841294caedd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5afcf70c2ce8271748f9a8fa16e8b88"><td class="memTemplParams" colspan="2">template&lt;class TIdIterator , class TLabelIterator , class TOutputIterator , class TFeatureFunctor &gt; </td></tr>
<tr class="memitem:ab5afcf70c2ce8271748f9a8fa16e8b88"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#ab5afcf70c2ce8271748f9a8fa16e8b88">probabilityGroupwise</a> (TIdIterator first_id, const TIdIterator last_id, TLabelIterator label_it, TOutputIterator out_it, const bool single_label, TFeatureFunctor &amp;&amp;feature_functor) const </td></tr>
<tr class="memdesc:ab5afcf70c2ce8271748f9a8fa16e8b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the probability of a certain value of the label for a set of data points.  <a href="#ab5afcf70c2ce8271748f9a8fa16e8b88">More...</a><br /></td></tr>
<tr class="separator:ab5afcf70c2ce8271748f9a8fa16e8b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73019f5709e606a43c5898abb4db60fb"><td class="memTemplParams" colspan="2">template&lt;class TIdIterator , class TLabelIterator , class TOutputIterator , class TFeatureFunctor &gt; </td></tr>
<tr class="memitem:a73019f5709e606a43c5898abb4db60fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#a73019f5709e606a43c5898abb4db60fb">probabilitySingle</a> (TIdIterator first_id, const TIdIterator last_id, TLabelIterator label_it, TOutputIterator out_it, const bool single_label, TFeatureFunctor &amp;&amp;feature_functor) const </td></tr>
<tr class="memdesc:a73019f5709e606a43c5898abb4db60fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the probability of a certain value of the label for a set of data points.  <a href="#a73019f5709e606a43c5898abb4db60fb">More...</a><br /></td></tr>
<tr class="separator:a73019f5709e606a43c5898abb4db60fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c278b76407e71773617dceb4cb5142"><td class="memTemplParams" colspan="2">template&lt;class TIdIterator , class TLabelIterator , class TOutputIterator , class TBinaryFunction , class TFeatureFunctor , class TPDFFunctor &gt; </td></tr>
<tr class="memitem:a20c278b76407e71773617dceb4cb5142"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#a20c278b76407e71773617dceb4cb5142">probabilityGroupwiseBase</a> (TIdIterator first_id, const TIdIterator last_id, TLabelIterator label_it, TOutputIterator out_it, const bool single_label, TBinaryFunction &amp;&amp;binary_function, TFeatureFunctor &amp;&amp;feature_functor, TPDFFunctor &amp;&amp;pdf_functor) const </td></tr>
<tr class="memdesc:a20c278b76407e71773617dceb4cb5142"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generalised version of the <code><a class="el" href="classcanopy_1_1random_forest_base.html#ab5afcf70c2ce8271748f9a8fa16e8b88" title="Evaluate the probability of a certain value of the label for a set of data points. ">probabilityGroupwise()</a></code> function that enables the creation of more general functions.  <a href="#a20c278b76407e71773617dceb4cb5142">More...</a><br /></td></tr>
<tr class="separator:a20c278b76407e71773617dceb4cb5142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6aac36bc8ce187cfae98cdbf190975"><td class="memTemplParams" colspan="2">template&lt;class TIdIterator , class TLabelIterator , class TOutputIterator , class TBinaryFunction , class TFeatureFunctor , class TPDFFunctor &gt; </td></tr>
<tr class="memitem:acb6aac36bc8ce187cfae98cdbf190975"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#acb6aac36bc8ce187cfae98cdbf190975">probabilitySingleBase</a> (TIdIterator first_id, const TIdIterator last_id, TLabelIterator label_it, TOutputIterator out_it, const bool single_label, TBinaryFunction &amp;&amp;binary_function, TFeatureFunctor &amp;&amp;feature_functor, TPDFFunctor &amp;&amp;pdf_functor) const </td></tr>
<tr class="memdesc:acb6aac36bc8ce187cfae98cdbf190975"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generalised version of the <code><a class="el" href="classcanopy_1_1random_forest_base.html#a73019f5709e606a43c5898abb4db60fb" title="Evaluate the probability of a certain value of the label for a set of data points. ">probabilitySingle()</a></code> function that enables the creation of more general functions.  <a href="#acb6aac36bc8ce187cfae98cdbf190975">More...</a><br /></td></tr>
<tr class="separator:acb6aac36bc8ce187cfae98cdbf190975"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ab98245bd4f015b9e6652f6744d0690ec"><td class="memTemplParams" colspan="2">template&lt;class TIdIterator , class TFeatureFunctor &gt; </td></tr>
<tr class="memitem:ab98245bd4f015b9e6652f6744d0690ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#ab98245bd4f015b9e6652f6744d0690ec">findLeavesGroupwise</a> (TIdIterator first_id, const TIdIterator last_id, const int treenum, std::vector&lt; const TNodeDist * &gt; &amp;leaves, TFeatureFunctor &amp;&amp;feature_functor) const </td></tr>
<tr class="memdesc:ab98245bd4f015b9e6652f6744d0690ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to query a single tree model with a set of data points and store a pointer to the leaf distribution that each reaches.  <a href="#ab98245bd4f015b9e6652f6744d0690ec">More...</a><br /></td></tr>
<tr class="separator:ab98245bd4f015b9e6652f6744d0690ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af809ee6c8d2db1014f836a4c4f7a77c4"><td class="memTemplParams" colspan="2">template&lt;class TId , class TFeatureFunctor &gt; </td></tr>
<tr class="memitem:af809ee6c8d2db1014f836a4c4f7a77c4"><td class="memTemplItemLeft" align="right" valign="top">const TNodeDist *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#af809ee6c8d2db1014f836a4c4f7a77c4">findLeafSingle</a> (const TId id, const int treenum, TFeatureFunctor &amp;&amp;feature_functor) const </td></tr>
<tr class="memdesc:af809ee6c8d2db1014f836a4c4f7a77c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to query a single tree model with a single data point and return a pointer to the leaf distribution that it reaches.  <a href="#af809ee6c8d2db1014f836a4c4f7a77c4">More...</a><br /></td></tr>
<tr class="separator:af809ee6c8d2db1014f836a4c4f7a77c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a8fcbaa753118df056efb4894279d8d13"><td class="memTemplParams" colspan="2">template&lt;class TLabelIterator &gt; </td></tr>
<tr class="memitem:a8fcbaa753118df056efb4894279d8d13"><td class="memTemplItemLeft" align="right" valign="top">static double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#a8fcbaa753118df056efb4894279d8d13">fastDiscreteEntropy</a> (const std::vector&lt; int &gt; &amp;internal_index, const int n_labels, const TLabelIterator first_label, const std::vector&lt; double &gt; &amp;xlogx_precalc)</td></tr>
<tr class="memdesc:a8fcbaa753118df056efb4894279d8d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the entropy of the discrete labels of a set of data points using an efficient method.  <a href="#a8fcbaa753118df056efb4894279d8d13">More...</a><br /></td></tr>
<tr class="separator:a8fcbaa753118df056efb4894279d8d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c035bc917583018a0ce3cddf4a720c"><td class="memTemplParams" colspan="2">template&lt;class TLabelIterator &gt; </td></tr>
<tr class="memitem:ad8c035bc917583018a0ce3cddf4a720c"><td class="memTemplItemLeft" align="right" valign="top">static int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#ad8c035bc917583018a0ce3cddf4a720c">fastDiscreteEntropySplit</a> (const std::vector&lt; <a class="el" href="structcanopy_1_1random_forest_base_1_1score_internal_index_struct.html">scoreInternalIndexStruct</a> &gt; &amp;data_structs, const int n_labels, const TLabelIterator first_label, const std::vector&lt; double &gt; &amp;xlogx_precalc, double &amp;best_split_impurity, float &amp;thresh)</td></tr>
<tr class="memdesc:ad8c035bc917583018a0ce3cddf4a720c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the split in a set of training data that results in the best information gain for discrete labels.  <a href="#ad8c035bc917583018a0ce3cddf4a720c">More...</a><br /></td></tr>
<tr class="separator:ad8c035bc917583018a0ce3cddf4a720c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677388c9a3916597d389b8189c39a9f8"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#a677388c9a3916597d389b8189c39a9f8">preCalculateXlogX</a> (const int N)</td></tr>
<tr class="memdesc:a677388c9a3916597d389b8189c39a9f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate an array of x*log(x) for integer x.  <a href="#a677388c9a3916597d389b8189c39a9f8">More...</a><br /></td></tr>
<tr class="separator:a677388c9a3916597d389b8189c39a9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:af2b2ae739f4a2fd9dd99baf4027dea45"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2b2ae739f4a2fd9dd99baf4027dea45"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#af2b2ae739f4a2fd9dd99baf4027dea45">n_trees</a></td></tr>
<tr class="memdesc:af2b2ae739f4a2fd9dd99baf4027dea45"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of trees in the forest. <br /></td></tr>
<tr class="separator:af2b2ae739f4a2fd9dd99baf4027dea45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3d1d8b770bb02dfccc63948ce27322"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe3d1d8b770bb02dfccc63948ce27322"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#abe3d1d8b770bb02dfccc63948ce27322">n_levels</a></td></tr>
<tr class="memdesc:abe3d1d8b770bb02dfccc63948ce27322"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of levels in each tree. <br /></td></tr>
<tr class="separator:abe3d1d8b770bb02dfccc63948ce27322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d370db45fce2b295071decedbb93b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91d370db45fce2b295071decedbb93b1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#a91d370db45fce2b295071decedbb93b1">n_nodes</a></td></tr>
<tr class="memdesc:a91d370db45fce2b295071decedbb93b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of nodes in each tree. <br /></td></tr>
<tr class="separator:a91d370db45fce2b295071decedbb93b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba612654496367659b1951694430600"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ba612654496367659b1951694430600"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#a7ba612654496367659b1951694430600">valid</a></td></tr>
<tr class="memdesc:a7ba612654496367659b1951694430600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the forest model is currently valid and usable for predictions (true = valid) <br /></td></tr>
<tr class="separator:a7ba612654496367659b1951694430600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dda9d0ce7c2dc57f3b747302d1492f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6dda9d0ce7c2dc57f3b747302d1492f8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#a6dda9d0ce7c2dc57f3b747302d1492f8">fit_split_nodes</a></td></tr>
<tr class="memdesc:a6dda9d0ce7c2dc57f3b747302d1492f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a node distribution is fitted to all nodes (true) or just the leaf nodes (false) <br /></td></tr>
<tr class="separator:a6dda9d0ce7c2dc57f3b747302d1492f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f902b8befa1467c4580d41fb7e7376"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13f902b8befa1467c4580d41fb7e7376"></a>
std::vector&lt; <a class="el" href="structcanopy_1_1random_forest_base_1_1tree.html">tree</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#a13f902b8befa1467c4580d41fb7e7376">forest</a></td></tr>
<tr class="memdesc:a13f902b8befa1467c4580d41fb7e7376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of tree models. <br /></td></tr>
<tr class="separator:a13f902b8befa1467c4580d41fb7e7376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1762732027985afe09ab09c722be1e71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1762732027985afe09ab09c722be1e71"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#a1762732027985afe09ab09c722be1e71">feature_header</a></td></tr>
<tr class="memdesc:a1762732027985afe09ab09c722be1e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">String describing the content of the feature string. <br /></td></tr>
<tr class="separator:a1762732027985afe09ab09c722be1e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc500e6049e65eadeaa97f3d6a47466"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2cc500e6049e65eadeaa97f3d6a47466"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#a2cc500e6049e65eadeaa97f3d6a47466">feature_string</a></td></tr>
<tr class="memdesc:a2cc500e6049e65eadeaa97f3d6a47466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arbitrary string describing the feature extraction process. <br /></td></tr>
<tr class="separator:a2cc500e6049e65eadeaa97f3d6a47466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49016a44f66b1b3e30683ec3dfaa75d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49016a44f66b1b3e30683ec3dfaa75d5"></a>
std::default_random_engine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#a49016a44f66b1b3e30683ec3dfaa75d5">rand_engine</a></td></tr>
<tr class="memdesc:a49016a44f66b1b3e30683ec3dfaa75d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random engine for generating random numbers during training, may also be used by derived classes. <br /></td></tr>
<tr class="separator:a49016a44f66b1b3e30683ec3dfaa75d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc3d5ea8b9b285fb6cf73b036dca7e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9bc3d5ea8b9b285fb6cf73b036dca7e4"></a>
std::uniform_int_distribution&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#a9bc3d5ea8b9b285fb6cf73b036dca7e4">uni_dist</a></td></tr>
<tr class="memdesc:a9bc3d5ea8b9b285fb6cf73b036dca7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">For generating random integers during traning, may also be used derived classes. <br /></td></tr>
<tr class="separator:a9bc3d5ea8b9b285fb6cf73b036dca7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:af9d0fefed5fe6b43bc6a13ebfe0f65c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9d0fefed5fe6b43bc6a13ebfe0f65c4"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#af9d0fefed5fe6b43bc6a13ebfe0f65c4">C_DEFAULT_MIN_TRAINING_DATA</a> = 50</td></tr>
<tr class="memdesc:af9d0fefed5fe6b43bc6a13ebfe0f65c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default value for the minimum number of traning data points in a node before a leaf is declared. <br /></td></tr>
<tr class="separator:af9d0fefed5fe6b43bc6a13ebfe0f65c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26bb427fd3744a3a5836ca939134ed4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26bb427fd3744a3a5836ca939134ed4e"></a>
static constexpr float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcanopy_1_1random_forest_base.html#a26bb427fd3744a3a5836ca939134ed4e">C_DEFAULT_BAGGING_PROPORTION</a> = 0.5</td></tr>
<tr class="memdesc:a26bb427fd3744a3a5836ca939134ed4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default value for the proportion of the traning set used to train each tree. <br /></td></tr>
<tr class="separator:a26bb427fd3744a3a5836ca939134ed4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class TDerived, class TLabel, class TNodeDist, class TOutputDist, unsigned TNumParams&gt;<br />
class canopy::randomForestBase&lt; TDerived, TLabel, TNodeDist, TOutputDist, TNumParams &gt;</h3>

<p>Base class for random forests models from which all specific models are derived using CRTP. </p>
<p>This class implements the basic training and testing routines, and some utility functions that may be used by derived classs. This class cannot not be used directly.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TDerived</td><td>The type of the derived random forests model (e.g. classifier, regressor). Having the derived class as a template parameter implements the curiously recurring template (CRTP) idiom, which allows for static polymorphism. </td></tr>
    <tr><td class="paramname">TLabel</td><td>The type of the label that the model is used to predict. This is the output type of the forest model, for example an integer for a classifier or a float for a 1D regressor. </td></tr>
    <tr><td class="paramname">TNodeDist</td><td>The type of the node distribution, which is the distribution stored at each leaf node. The node distribution must have certain characteristics. </td></tr>
    <tr><td class="paramname">TOutputDist</td><td>The type of the output distribution, which is the type of the distribution predicted by the forest model. This may be same as or different from TNodeDist. The output distribution must have certain charaecteristics. </td></tr>
    <tr><td class="paramname">TNumParams</td><td>The number of parameters used by the features callback. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a70c06b08b674b7cad75a78936c35638a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDerived , class TLabel , class TNodeDist , class TOutputDist , unsigned TNumParams&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcanopy_1_1random_forest_base.html">canopy::randomForestBase</a>&lt; TDerived, TLabel, TNodeDist, TOutputDist, TNumParams &gt;::<a class="el" href="classcanopy_1_1random_forest_base.html">randomForestBase</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Note that an object initialised in this way should not be trained, but may be used to read in a pre-trained model using <code><a class="el" href="classcanopy_1_1random_forest_base.html#a7bd7e5ec068f3dfe3d407693c9b65ae3" title="Read a pre-trained model in from a file. ">readFromFile()</a></code> </p>

</div>
</div>
<a class="anchor" id="a514c0a85f7b671a43a85a0735931f1f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDerived , class TLabel , class TNodeDist , class TOutputDist , unsigned TNumParams&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcanopy_1_1random_forest_base.html">canopy::randomForestBase</a>&lt; TDerived, TLabel, TNodeDist, TOutputDist, TNumParams &gt;::<a class="el" href="classcanopy_1_1random_forest_base.html">randomForestBase</a> </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_trees</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_levels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Full constructor. </p>
<p>Creates a full forest with a specified number of trees and levels, ready to be trained. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_trees</td><td>The number of decision trees in the forest </td></tr>
    <tr><td class="paramname">num_levels</td><td>The maximum depth of any node in the trees </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a8fcbaa753118df056efb4894279d8d13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDerived , class TLabel , class TNodeDist , class TOutputDist , unsigned TNumParams&gt; </div>
<div class="memtemplate">
template&lt;class TLabelIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classcanopy_1_1random_forest_base.html">canopy::randomForestBase</a>&lt; TDerived, TLabel, TNodeDist, TOutputDist, TNumParams &gt;::fastDiscreteEntropy </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>internal_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n_labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TLabelIterator&#160;</td>
          <td class="paramname"><em>first_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>xlogx_precalc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the entropy of the discrete labels of a set of data points using an efficient method. </p>
<p>This is utility method that is provided for use in subclasses if convenient.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TLabelIterator</td><td>Type of the iterator used to access the discrete labels. Must be a random access iterator that dereferences to an integral data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">internal_index</td><td>Vector containing the internal training indices of the data points. These are the indices through which the labels may be accessed in first_label </td></tr>
    <tr><td class="paramname">n_labels</td><td>The number of discrete labels. The possible values of the label are assumed to be the integers in the range 0 to n_labels-1 </td></tr>
    <tr><td class="paramname">first_label</td><td>Iterator to the labels for which the entropy is to be calculated. The labels should be located at the offsets from this iterator given by the elements of the internal_index vector. I.e. first_label[internal_index[0]], first_label[internal_index[1]] etc. </td></tr>
    <tr><td class="paramname">xlogx_precalc</td><td>A pre-calculated array of the value of x*log(x), as calculated by the <code><a class="el" href="classcanopy_1_1random_forest_base.html#a677388c9a3916597d389b8189c39a9f8" title="Calculate an array of x*log(x) for integer x. ">preCalculateXlogX()</a></code> routine. This must be long enough to include the value for x = internal_index.size() or greater. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The entropy of the set of labels. </dd></dl>

</div>
</div>
<a class="anchor" id="ad8c035bc917583018a0ce3cddf4a720c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDerived , class TLabel , class TNodeDist , class TOutputDist , unsigned TNumParams&gt; </div>
<div class="memtemplate">
template&lt;class TLabelIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classcanopy_1_1random_forest_base.html">canopy::randomForestBase</a>&lt; TDerived, TLabel, TNodeDist, TOutputDist, TNumParams &gt;::fastDiscreteEntropySplit </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structcanopy_1_1random_forest_base_1_1score_internal_index_struct.html">scoreInternalIndexStruct</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_structs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n_labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TLabelIterator&#160;</td>
          <td class="paramname"><em>first_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>xlogx_precalc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>best_split_impurity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>thresh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the split in a set of training data that results in the best information gain for discrete labels. </p>
<p>This is utility method that is provided for use in subclasses if convenient.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TLabelIterator</td><td>Type of the iterator used to access the discrete labels. Must be a random access iterator that dereferences to an integral data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_structs</td><td>A vector in which each element is a structure containing the internal id (.id) and score (.score) for the current feature of the training data points. The vector is assumed to be sorted according to the score field in ascending order. </td></tr>
    <tr><td class="paramname">n_labels</td><td>The number of discrete labels. The possible values of the label are assumed to be the integers in the range 0 to n_labels-1 </td></tr>
    <tr><td class="paramname">first_label</td><td>Iterator to the labels for which the entropy is to be calculated. The labels should be located at the offsets from this iterator given by the IDs of elements of the data_structs vector. I.e. first_label[data_structs[0].id], first_label[data_structs[1].id] etc. </td></tr>
    <tr><td class="paramname">xlogx_precalc</td><td>A pre-calculated array of the value of x*log(x), as calculated by the <code><a class="el" href="classcanopy_1_1random_forest_base.html#a677388c9a3916597d389b8189c39a9f8" title="Calculate an array of x*log(x) for integer x. ">preCalculateXlogX()</a></code> routine. This must be long enough to include the value for x = data_structs.size() or greater. </td></tr>
    <tr><td class="paramname">best_split_impurity</td><td>Returns by reference the impurity of the best split found. </td></tr>
    <tr><td class="paramname">thresh</td><td>Returns by reference the threshold of the feature score that gives the best split. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position 'd' of the best split in the training data. The partition of the data resulting in the best split has the first d+1 elements in one partiiton and the remainder in the other partition. </dd></dl>

</div>
</div>
<a class="anchor" id="af809ee6c8d2db1014f836a4c4f7a77c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDerived , class TLabel , class TNodeDist , class TOutputDist , unsigned TNumParams&gt; </div>
<div class="memtemplate">
template&lt;class TId , class TFeatureFunctor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const TNodeDist * <a class="el" href="classcanopy_1_1random_forest_base.html">canopy::randomForestBase</a>&lt; TDerived, TLabel, TNodeDist, TOutputDist, TNumParams &gt;::findLeafSingle </td>
          <td>(</td>
          <td class="paramtype">const TId&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>treenum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFeatureFunctor &amp;&amp;&#160;</td>
          <td class="paramname"><em>feature_functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to query a single tree model with a single data point and return a pointer to the leaf distribution that it reaches. </p>
<p>This is a basic operation that is used by higher-level processes. Using this method.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TId</td><td>Type of the ID used to identify the data point. </td></tr>
    <tr><td class="paramname">TFeatureFunctor</td><td>The type of the feature functor object. Must meet the specifications for a groupwise feature functor object, meaning it must define operator() with a certain form. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_id</td><td>ID of the data point for which the leaf distribution is to be found. </td></tr>
    <tr><td class="paramname">treenum</td><td>Index of the tree to use. </td></tr>
    <tr><td class="paramname">feature_functor</td><td>The feature functor object to be used as a callback to calculate the features. Must be safe to call from multiple threads simultaneously. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointers to the leaf distribution reached by the data point. </dd></dl>

</div>
</div>
<a class="anchor" id="ab98245bd4f015b9e6652f6744d0690ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDerived , class TLabel , class TNodeDist, class TOutputDist , unsigned TNumParams&gt; </div>
<div class="memtemplate">
template&lt;class TIdIterator , class TFeatureFunctor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcanopy_1_1random_forest_base.html">canopy::randomForestBase</a>&lt; TDerived, TLabel, TNodeDist, TOutputDist, TNumParams &gt;::findLeavesGroupwise </td>
          <td>(</td>
          <td class="paramtype">TIdIterator&#160;</td>
          <td class="paramname"><em>first_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIdIterator&#160;</td>
          <td class="paramname"><em>last_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>treenum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const TNodeDist * &gt; &amp;&#160;</td>
          <td class="paramname"><em>leaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFeatureFunctor &amp;&amp;&#160;</td>
          <td class="paramname"><em>feature_functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to query a single tree model with a set of data points and store a pointer to the leaf distribution that each reaches. </p>
<p>This is a basic operation that is used by higher-level processes. Using this method, the features needed by a single node are requested from the feature functor for all the IDs with a single function call. This involves some overhead, but may permit efficiencies resulting from calculating multiple features at once.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIdIterator</td><td>Type of the iterator to the IDs. Must be a random access iterator and dereference to the TId type expected by the feature functor. </td></tr>
    <tr><td class="paramname">TFeatureFunctor</td><td>The type of the feature functor object. Must meet the specifications for a groupwise feature functor object, meaning it must define operator() with a certain form. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_id</td><td>Iterator to the ID of the first data point for which the leaf distribution is to be found. </td></tr>
    <tr><td class="paramname">last_id</td><td>Iterator to the ID of the last data point for which the leaf distribution is to be found. </td></tr>
    <tr><td class="paramname">treenum</td><td>Index of the tree to use. </td></tr>
    <tr><td class="paramname">leaves</td><td>After the function, this array contains pointers to the leaf distribution reached by the corresponding elements in the ID list. Expects to be pre-allocated to the correct size. </td></tr>
    <tr><td class="paramname">feature_functor</td><td>The feature functor object to be used as a callback to calculate the features. Must be safe to call from multiple threads simultaneously. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4276dd9b1b3137cc26c3fb89494b375e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDerived , class TLabel , class TNodeDist , class TOutputDist , unsigned TNumParams&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcanopy_1_1random_forest_base.html">canopy::randomForestBase</a>&lt; TDerived, TLabel, TNodeDist, TOutputDist, TNumParams &gt;::getFeatureDefinitionString </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>feat_str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a stored feature string. </p>
<p>This method is used to retrieve a feature string previously stored in the model. This string may be used to store paratmers of the feature extraction process used to train the model. The parsing of this string is leftentirely up to the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">feature_string</td><td>The stored string is returned by reference in this variable. If no string has been stored, an empty string is returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8925a133e8a91126d12834ff7f1b837a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDerived , class TLabel , class TNodeDist , class TOutputDist , unsigned TNumParams&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcanopy_1_1random_forest_base.html">canopy::randomForestBase</a>&lt; TDerived, TLabel, TNodeDist, TOutputDist, TNumParams &gt;::isValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a forest model is valid. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the forest has either been successfully trained or successfully read from a file and is therefore ready to use. False otherwise. If false, the model should not be used. </dd></dl>

</div>
</div>
<a class="anchor" id="a677388c9a3916597d389b8189c39a9f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDerived , class TLabel , class TNodeDist , class TOutputDist , unsigned TNumParams&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; <a class="el" href="classcanopy_1_1random_forest_base.html">canopy::randomForestBase</a>&lt; TDerived, TLabel, TNodeDist, TOutputDist, TNumParams &gt;::preCalculateXlogX </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate an array of x*log(x) for integer x. </p>
<p>This is a utility routine provided for subclasses to make use of if convenient. The quantity x*log(x) arises in many entropy-based calculations, including the <code><a class="el" href="classcanopy_1_1random_forest_base.html#a8fcbaa753118df056efb4894279d8d13" title="Calculates the entropy of the discrete labels of a set of data points using an efficient method...">fastDiscreteEntropy()</a></code> and <code><a class="el" href="classcanopy_1_1random_forest_base.html#ad8c035bc917583018a0ce3cddf4a720c" title="Find the split in a set of training data that results in the best information gain for discrete label...">fastDiscreteEntropySplit()</a></code> calculations, and needs to be calculated a very large number of times in such routines. This method pre-calculates an array of x*log(x) for integers x in the range 0 to N inclusive, such that it may be used by other routines to speed up calculations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Upper limit of the range of values for x </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector 'result' of length N+1 where result[i] has the value i*log(i), and result[0] = 0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a1863eb32b1ae355c52c53669dd543593"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDerived , class TLabel , class TNodeDist , class TOutputDist , unsigned TNumParams&gt; </div>
<div class="memtemplate">
template&lt;class TIdIterator , class TOutputIterator , class TFeatureFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcanopy_1_1random_forest_base.html">canopy::randomForestBase</a>&lt; TDerived, TLabel, TNodeDist, TOutputDist, TNumParams &gt;::predictDistGroupwise </td>
          <td>(</td>
          <td class="paramtype">TIdIterator&#160;</td>
          <td class="paramname"><em>first_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIdIterator&#160;</td>
          <td class="paramname"><em>last_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>out_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFeatureFunctor &amp;&amp;&#160;</td>
          <td class="paramname"><em>feature_functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predict the output distribution for a number of IDs. </p>
<p>This function uses the forest model to predict the full output distribution for each of a number of data points, where each data point is identified by an ID variable.</p>
<p>These ID variables are passed in as a pair of iterators pointing to the first and last IDs to be processed. The output distribution for each of these IDs is placed in a second container accessed by iterators.</p>
<p>In this version of the function, the features needed by a single node are requested from the feature functor for all the IDs with a single function call. This involves some overhead, but may permit efficiencies resulting from calculating multiple features at once.</p>
<p>Uses OpenMP to query the multiple tree models in parallel.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIdIterator</td><td>Type of the iterator to the IDs. Must be a random access iterator and dereference to the TId type expected by the feature functor. </td></tr>
    <tr><td class="paramname">TOutputIterator</td><td>Type of the iterator to the output distributions. Must be a forward output iterator that dereferences to TOutputDist. </td></tr>
    <tr><td class="paramname">TFeatureFunctor</td><td>The type of the feature functor object. Must meet the specifications for a groupwise feature functor object, meaning it must define operator() with a certain form. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_id</td><td>Iterator to the first ID whose output is to be predicted. </td></tr>
    <tr><td class="paramname">last_id</td><td>Iterator to the last ID whose output is to be predicted. </td></tr>
    <tr><td class="paramname">out_it</td><td>Iterator to the output distribution corresponding to the first ID. The container of output distributions must already exist, and contain enough elements for all of the IDs between first_id and last_id. At the end of this function, the output distributions in this container relate to the corresponding elements of the id container. </td></tr>
    <tr><td class="paramname">feature_functor</td><td>The feature functor object to be used as a callback to calculate the features. Must be safe to call from multiple threads simultaneously. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a99ba77f1b521fc6992a8841294caedd1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDerived , class TLabel , class TNodeDist , class TOutputDist , unsigned TNumParams&gt; </div>
<div class="memtemplate">
template&lt;class TIdIterator , class TOutputIterator , class TFeatureFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcanopy_1_1random_forest_base.html">canopy::randomForestBase</a>&lt; TDerived, TLabel, TNodeDist, TOutputDist, TNumParams &gt;::predictDistSingle </td>
          <td>(</td>
          <td class="paramtype">TIdIterator&#160;</td>
          <td class="paramname"><em>first_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIdIterator&#160;</td>
          <td class="paramname"><em>last_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>out_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFeatureFunctor &amp;&amp;&#160;</td>
          <td class="paramname"><em>feature_functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predict the output distribution for a number of IDs. </p>
<p>This function uses the forest model to predict the full output distribution for each of a number of data points, where each data poitn is identified by an ID variable.</p>
<p>These ID variables are passed in as a pair of iterators pointing to the first and last IDs to be processed. The output distribution for each of these IDs is placed in a second container accessed by iterators.</p>
<p>In this version of the function, the features needed by a single node are requested from the feature functor one-by-one.</p>
<p>Uses OpenMP to query the multiple tree models in parallel.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIdIterator</td><td>Type of the iterator to the IDs. Must be a random access iterator and dereference to the TId type expected by the feature functor. </td></tr>
    <tr><td class="paramname">TOutputIterator</td><td>Type of the iterator to the output distributions. Must be a forward output iterator that dereferences to TOutputDist. </td></tr>
    <tr><td class="paramname">TFeatureFunctor</td><td>The type of the feature functor object. Must meet the specifications for a single feature functor object, meaning it must define operator() with a certain form. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_id</td><td>Iterator to the first ID whose output is to be predicted. </td></tr>
    <tr><td class="paramname">last_id</td><td>Iterator to the last ID whose output is to be predicted. </td></tr>
    <tr><td class="paramname">out_it</td><td>Iterator to the output distribution corresponding to the first ID. The container of output distributions must already exist, and contain enough elements for all of the IDs between first_id and last_id. At the end of this function, the output distributions in this container relate to the corresponding elements of the id container. </td></tr>
    <tr><td class="paramname">feature_functor</td><td>The feature functor object to be used as a callback to calculate the features. Must be safe to call from multiple threads simultaneously. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab5afcf70c2ce8271748f9a8fa16e8b88"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDerived , class TLabel , class TNodeDist , class TOutputDist , unsigned TNumParams&gt; </div>
<div class="memtemplate">
template&lt;class TIdIterator , class TLabelIterator , class TOutputIterator , class TFeatureFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcanopy_1_1random_forest_base.html">canopy::randomForestBase</a>&lt; TDerived, TLabel, TNodeDist, TOutputDist, TNumParams &gt;::probabilityGroupwise </td>
          <td>(</td>
          <td class="paramtype">TIdIterator&#160;</td>
          <td class="paramname"><em>first_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIdIterator&#160;</td>
          <td class="paramname"><em>last_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TLabelIterator&#160;</td>
          <td class="paramname"><em>label_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>out_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>single_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFeatureFunctor &amp;&amp;&#160;</td>
          <td class="paramname"><em>feature_functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the probability of a certain value of the label for a set of data points. </p>
<p>This function uses the forest model to evaluate the probability of a given value of the label (output) variable for a number of data points, where each point data is identified by an ID variable.</p>
<p>These ID variables are passed in as a pair of iterators pointing to the first and last IDs to be processed. The value of the label for which the probability should be evaluated is passed in as a second iterator. The probability of the label for each of these IDs is placed in a third container accessed by iterators.</p>
<p>In this version of the function, the features needed by a single node are requested from the feature functor for all the IDs with a single function call. This involves some overhead, but may permit efficiencies resulting from calculating multiple features at once.</p>
<p>Uses OpenMP to query the multiple tree models in parallel.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIdIterator</td><td>Type of the iterator to the IDs. Must be a random access iterator and dereference to the TId type expected by the feature functor. </td></tr>
    <tr><td class="paramname">TLabelIterator</td><td>Type of the iterator to the IDs. Must be a random access iterator and dereference to the TLabel type of the forest (or to something trivially convertible to that type). </td></tr>
    <tr><td class="paramname">TOutputIterator</td><td>Type of the iterator to the output. Must be a forward output iterator that dereferences to a type that supports assignment to float. </td></tr>
    <tr><td class="paramname">TFeatureFunctor</td><td>The type of the feature functor object. Must meet the specifications for a groupwise feature functor object, meaning it must define operator() with a certain form. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_id</td><td>Iterator to the ID of the first data point for which the probability of the label is to be evaluated. </td></tr>
    <tr><td class="paramname">last_id</td><td>Iterator to the ID of the last data point for which the probability of the label is to be evaluated. </td></tr>
    <tr><td class="paramname">label_it</td><td>Iterator to the label variable whose probability is to be evaluated. </td></tr>
    <tr><td class="paramname">out_it</td><td>Iterator to the output probability value for the first ID. The container of output values must already exist, and contain enough elements for all of the IDs between first_id and last_id. At the end of this function, the output values in this container relate to the corresponding elements of the id container. </td></tr>
    <tr><td class="paramname">single_label</td><td>If true, the value of the label whose probability is evaluated is the same for all the data points. This means that the label_it iterator is never advanced. If false, the value of the label is not necessarily the same for all data points, and the label_it iterator is advanced for each data point to give the value of the label to use. </td></tr>
    <tr><td class="paramname">feature_functor</td><td>The feature functor object to be used as a callback to calculate the features. Must be safe to call from multiple threads simultaneously. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a20c278b76407e71773617dceb4cb5142"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDerived , class TLabel , class TNodeDist , class TOutputDist , unsigned TNumParams&gt; </div>
<div class="memtemplate">
template&lt;class TIdIterator , class TLabelIterator , class TOutputIterator , class TBinaryFunction , class TFeatureFunctor , class TPDFFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcanopy_1_1random_forest_base.html">canopy::randomForestBase</a>&lt; TDerived, TLabel, TNodeDist, TOutputDist, TNumParams &gt;::probabilityGroupwiseBase </td>
          <td>(</td>
          <td class="paramtype">TIdIterator&#160;</td>
          <td class="paramname"><em>first_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIdIterator&#160;</td>
          <td class="paramname"><em>last_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TLabelIterator&#160;</td>
          <td class="paramname"><em>label_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>out_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>single_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TBinaryFunction &amp;&amp;&#160;</td>
          <td class="paramname"><em>binary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFeatureFunctor &amp;&amp;&#160;</td>
          <td class="paramname"><em>feature_functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TPDFFunctor &amp;&amp;&#160;</td>
          <td class="paramname"><em>pdf_functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A generalised version of the <code><a class="el" href="classcanopy_1_1random_forest_base.html#ab5afcf70c2ce8271748f9a8fa16e8b88" title="Evaluate the probability of a certain value of the label for a set of data points. ">probabilityGroupwise()</a></code> function that enables the creation of more general functions. </p>
<p>A generalised version of the <code><a class="el" href="classcanopy_1_1random_forest_base.html#ab5afcf70c2ce8271748f9a8fa16e8b88" title="Evaluate the probability of a certain value of the label for a set of data points. ">probabilityGroupwise()</a></code> function. There are two generalisations:</p><ol type="1">
<li>The pdf value may be calculated from the node distribution in some way other than the calling the pdf() method. This enables, for example, accessing one distribution from a node distribution that contains multiple distributions over different variables. This behaviour is controlled by the pdf_functor object.</li>
<li>The output probability value may be used for something other than simple assignment to a variable. This may be used, for example, to use the output value to update some other variable (via multiplication or addtition etc) in a single step without having to store results in a temporary array. This behaviour is controlled by the binary_function functor object.</li>
</ol>
<p>Unless otherwise specified, the behaviour is the same as the <code><a class="el" href="classcanopy_1_1random_forest_base.html#ab5afcf70c2ce8271748f9a8fa16e8b88" title="Evaluate the probability of a certain value of the label for a set of data points. ">probabilityGroupwise()</a></code> function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIdIterator</td><td>Type of the iterator to the IDs. Must be a random access iterator and dereference to the TId type expected by the feature functor. </td></tr>
    <tr><td class="paramname">TLabelIterator</td><td>Type of the iterator to the IDs. Must be a random access iterator and dereference to the TLabel type of the forest (or to something trivially convertible to that type). </td></tr>
    <tr><td class="paramname">TOutputIterator</td><td>Type of the iterator to the output. Must be a forward output iterator that dereferences to a type that supports assignment to float. </td></tr>
    <tr><td class="paramname">TBinaryFunction</td><td>The type of the binary_function argument. Must be a function object that has an operator() of the form float operator()(TOutput, float) where TOutput is the type that TOutputIterator dereferences to. </td></tr>
    <tr><td class="paramname">TFeatureFunctor</td><td>The type of the feature functor object. Must meet the specifications for a groupwise feature functor object, meaning it must define operator() with a certain form. </td></tr>
    <tr><td class="paramname">TPDFFunctor</td><td>The type of the pdf_functor argument. Must be a function object that has an operator() of the form float operator()(TNodeDist*, TLabel, TId). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_id</td><td>Iterator to the ID of the first data point for which the probability of the label is to be evaluated. </td></tr>
    <tr><td class="paramname">last_id</td><td>Iterator to the ID of the last data point for which the probability of the label is to be evaluated. </td></tr>
    <tr><td class="paramname">label_it</td><td>Iterator to the label variable whose probability is to be evaluated. </td></tr>
    <tr><td class="paramname">out_it</td><td>Iterator to the output probability value for the first ID. The container of output values must already exist, and contain enough elements for all of the IDs between first_id and last_id. At the end of this function, the output values in this container relate to the corresponding elements of the id container. </td></tr>
    <tr><td class="paramname">single_label</td><td>If true, the value of the label whose probability is evaluated is the same for all the data points. This means that the label_it iterator is never advanced. If false, the value of the label is not necessarily the same for all data points, and the label_it iterator is advanced for each data point to give the value of the label to use. </td></tr>
    <tr><td class="paramname">binary_function</td><td>A function object that takes the current value of the output variable (first argument) and the forest's predicted probability value (second) argument and returns the value that is then assigned to the output variable. </td></tr>
    <tr><td class="paramname">feature_functor</td><td>The feature functor object to be used as a callback to calculate the features. Must be safe to call from multiple threads simultaneously. </td></tr>
    <tr><td class="paramname">pdf_functor</td><td>A function object that takes a pointer to the leaf distribution reached by the forest (first argument), a lable value (second argument), and an ID (third argument) and returns the value used as the pdf for the that leaf distribution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a73019f5709e606a43c5898abb4db60fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDerived , class TLabel , class TNodeDist , class TOutputDist , unsigned TNumParams&gt; </div>
<div class="memtemplate">
template&lt;class TIdIterator , class TLabelIterator , class TOutputIterator , class TFeatureFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcanopy_1_1random_forest_base.html">canopy::randomForestBase</a>&lt; TDerived, TLabel, TNodeDist, TOutputDist, TNumParams &gt;::probabilitySingle </td>
          <td>(</td>
          <td class="paramtype">TIdIterator&#160;</td>
          <td class="paramname"><em>first_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIdIterator&#160;</td>
          <td class="paramname"><em>last_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TLabelIterator&#160;</td>
          <td class="paramname"><em>label_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>out_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>single_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFeatureFunctor &amp;&amp;&#160;</td>
          <td class="paramname"><em>feature_functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the probability of a certain value of the label for a set of data points. </p>
<p>This function uses the forest model to evaluate the probability of a given value of the label (output) variable for a number of data points, where each point data is identified by an ID variable.</p>
<p>These ID variables are passed in as a pair of iterators pointing to the first and last IDs to be processed. The value of the label for which the probability should be evaluated is passed in as a second iterator. The probability of the label for each of these IDs is placed in a third container accessed by iterators.</p>
<p>In this version of the function, the features needed by a single node are requested from the feature functor one-by-one.</p>
<p>Uses OpenMP to query the multiple tree models in parallel.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIdIterator</td><td>Type of the iterator to the IDs. Must be a random access iterator and dereference to the TId type expected by the feature functor. </td></tr>
    <tr><td class="paramname">TLabelIterator</td><td>Type of the iterator to the IDs. Must be a random access iterator and dereference to the TLabel type of the forest (or to something trivially convertible to that type). </td></tr>
    <tr><td class="paramname">TOutputIterator</td><td>Type of the iterator to the output. Must be a forward output iterator that dereferences to a type that supports assignment to float. </td></tr>
    <tr><td class="paramname">TFeatureFunctor</td><td>The type of the feature functor object. Must meet the specifications for a groupwise feature functor object, meaning it must define operator() with a certain form. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_id</td><td>Iterator to the ID of the first data point for which the probability of the label is to be evaluated. </td></tr>
    <tr><td class="paramname">last_id</td><td>Iterator to the ID of the last data point for which the probability of the label is to be evaluated. </td></tr>
    <tr><td class="paramname">label_it</td><td>Iterator to the label variable whose probability is to be evaluated. </td></tr>
    <tr><td class="paramname">out_it</td><td>Iterator to the output probability value for the first ID. The container of output values must already exist, and contain enough elements for all of the IDs between first_id and last_id. At the end of this function, the output values in this container relate to the corresponding elements of the id container. </td></tr>
    <tr><td class="paramname">single_label</td><td>If true, the value of the label whose probability is evaluated is the same for all the data points. This means that the label_it iterator is never advanced. If false, the value of the label is not necessarily the same for all data points, and the label_it iterator is advanced for each data point to give the value of the label to use. </td></tr>
    <tr><td class="paramname">feature_functor</td><td>The feature functor object to be used as a callback to calculate the features. Must be safe to call from multiple threads simultaneously. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acb6aac36bc8ce187cfae98cdbf190975"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDerived , class TLabel , class TNodeDist , class TOutputDist , unsigned TNumParams&gt; </div>
<div class="memtemplate">
template&lt;class TIdIterator , class TLabelIterator , class TOutputIterator , class TBinaryFunction , class TFeatureFunctor , class TPDFFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcanopy_1_1random_forest_base.html">canopy::randomForestBase</a>&lt; TDerived, TLabel, TNodeDist, TOutputDist, TNumParams &gt;::probabilitySingleBase </td>
          <td>(</td>
          <td class="paramtype">TIdIterator&#160;</td>
          <td class="paramname"><em>first_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIdIterator&#160;</td>
          <td class="paramname"><em>last_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TLabelIterator&#160;</td>
          <td class="paramname"><em>label_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>out_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>single_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TBinaryFunction &amp;&amp;&#160;</td>
          <td class="paramname"><em>binary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFeatureFunctor &amp;&amp;&#160;</td>
          <td class="paramname"><em>feature_functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TPDFFunctor &amp;&amp;&#160;</td>
          <td class="paramname"><em>pdf_functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A generalised version of the <code><a class="el" href="classcanopy_1_1random_forest_base.html#a73019f5709e606a43c5898abb4db60fb" title="Evaluate the probability of a certain value of the label for a set of data points. ">probabilitySingle()</a></code> function that enables the creation of more general functions. </p>
<p>A generalised version of the <code><a class="el" href="classcanopy_1_1random_forest_base.html#a73019f5709e606a43c5898abb4db60fb" title="Evaluate the probability of a certain value of the label for a set of data points. ">probabilitySingle()</a></code> function. There are two generalisations:</p><ol type="1">
<li>The pdf value may be calculated from the node distribution in some way other than the calling the pdf() method. This enables, for example, accessing one distribution from a node distribution that contains multiple distributions over different variables. This behaviour is controlled by the pdf_functor object.</li>
<li>The output probability value may be used for something other than simple assignment to a variable. This may be used, for example, to use the output value to update some other variable (via multiplication or addtition etc) in a single step without having to store results in a temporary array. This behaviour is controlled by the binary_function functor object.</li>
</ol>
<p>Unless otherwise specified, the behaviour is the same as the <code><a class="el" href="classcanopy_1_1random_forest_base.html#a73019f5709e606a43c5898abb4db60fb" title="Evaluate the probability of a certain value of the label for a set of data points. ">probabilitySingle()</a></code> function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIdIterator</td><td>Type of the iterator to the IDs. Must be a random access iterator and dereference to the TId type expected by the feature functor. </td></tr>
    <tr><td class="paramname">TLabelIterator</td><td>Type of the iterator to the IDs. Must be a random access iterator and dereference to the TLabel type of the forest (or to something trivially convertible to that type). </td></tr>
    <tr><td class="paramname">TOutputIterator</td><td>Type of the iterator to the output. Must be a forward output iterator that dereferences to a type that supports assignment to float. </td></tr>
    <tr><td class="paramname">TBinaryFunction</td><td>The type of the binary_function argument. Must be a function object that has an operator() of the form float operator()(TOutput, float) where TOutput is the type that TOutputIterator dereferences to. </td></tr>
    <tr><td class="paramname">TFeatureFunctor</td><td>The type of the feature functor object. Must meet the specifications for a groupwise feature functor object, meaning it must define operator() with a certain form. </td></tr>
    <tr><td class="paramname">TPDFFunctor</td><td>The type of the pdf_functor argument. Must be a function object that has an operator() of the form float operator()(TNodeDist*, TLabel, TId). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_id</td><td>Iterator to the ID of the first data point for which the probability of the label is to be evaluated. </td></tr>
    <tr><td class="paramname">last_id</td><td>Iterator to the ID of the last data point for which the probability of the label is to be evaluated. </td></tr>
    <tr><td class="paramname">label_it</td><td>Iterator to the label variable whose probability is to be evaluated. </td></tr>
    <tr><td class="paramname">out_it</td><td>Iterator to the output probability value for the first ID. The container of output values must already exist, and contain enough elements for all of the IDs between first_id and last_id. At the end of this function, the output values in this container relate to the corresponding elements of the id container. </td></tr>
    <tr><td class="paramname">single_label</td><td>If true, the value of the label whose probability is evaluated is the same for all the data points. This means that the label_it iterator is never advanced. If false, the value of the label is not necessarily the same for all data points, and the label_it iterator is advanced for each data point to give the value of the label to use. </td></tr>
    <tr><td class="paramname">binary_function</td><td>A function object that takes the current value of the output variable (first argument) and the forest's predicted probability value (second) argument and returns the value that is then assigned to the output variable. </td></tr>
    <tr><td class="paramname">feature_functor</td><td>The feature functor object to be used as a callback to calculate the features. Must be safe to call from multiple threads simultaneously. </td></tr>
    <tr><td class="paramname">pdf_functor</td><td>A function object that takes a pointer to the leaf distribution reached by the forest (first argument), a lable value (second argument), and an ID (third argument) and returns the value used as the pdf for the that leaf distribution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7bd7e5ec068f3dfe3d407693c9b65ae3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDerived , class TLabel , class TNodeDist , class TOutputDist , unsigned TNumParams&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcanopy_1_1random_forest_base.html">canopy::randomForestBase</a>&lt; TDerived, TLabel, TNodeDist, TOutputDist, TNumParams &gt;::readFromFile </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>trees_used</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>max_depth_used</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a pre-trained model in from a file. </p>
<p>Read in the parameters for a forest from a pre-trained model stored in a .tr file. After this function, the object will be ready to use for testing with the pre-trained model.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The full name and path of the .tr file to read. </td></tr>
    <tr><td class="paramname">trees_used</td><td>The number of trees to read in from the file. If this is unspecified or set to a negative value, all the trees in the .tr file will be used. If the number specified is greater than the number trianed in .tr file, the function will fail and return zero. </td></tr>
    <tr><td class="paramname">max_depth_used</td><td>The maximum tree depth to read from the the file. If this is unspecified or set to a negative value, all the levels in the .tr file will be used. If the number specified is greater than the number trianed in .tr file, the function will fail and return zero. The .tr must have been trained with the fit_split_nodes option set to true for this option to be successful. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the model was successfully read from the file, false otherwise. If false, the model should not be used. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b9f270fe6df6f17ac6f86f1b550fb4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDerived , class TLabel , class TNodeDist , class TOutputDist , unsigned TNumParams&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcanopy_1_1random_forest_base.html">canopy::randomForestBase</a>&lt; TDerived, TLabel, TNodeDist, TOutputDist, TNumParams &gt;::setFeatureDefinitionString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>header_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>feat_str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store arbitrary strings that define parameters of the feature extraction process. </p>
<p>This string is stored alongside the model, enabling the storage of information necessary to recreate the same feature extraction process at test time. The construction (and later parsing) of this string is left entirely up to the user. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">header_str</td><td>This string will be printed above the feature string and is intended to help human readility of the string by explaining the meaning of the terms in the feature string. </td></tr>
    <tr><td class="paramname">feat_str</td><td>Arbitrary string containing data that can later be used to recreate the feature extraction process. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc82fbe49123558dd5ee597f005cb16b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDerived , class TLabel , class TNodeDist , class TOutputDist , unsigned TNumParams&gt; </div>
<div class="memtemplate">
template&lt;class TIdIterator , class TLabelIterator , class TFeatureFunctor , class TParameterFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcanopy_1_1random_forest_base.html">canopy::randomForestBase</a>&lt; TDerived, TLabel, TNodeDist, TOutputDist, TNumParams &gt;::train </td>
          <td>(</td>
          <td class="paramtype">const TIdIterator&#160;</td>
          <td class="paramname"><em>first_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIdIterator&#160;</td>
          <td class="paramname"><em>last_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TLabelIterator&#160;</td>
          <td class="paramname"><em>first_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFeatureFunctor &amp;&amp;&#160;</td>
          <td class="paramname"><em>feature_functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TParameterFunctor &amp;&amp;&#160;</td>
          <td class="paramname"><em>parameter_functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>num_param_combos_to_test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>bagging</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>bag_proportion</em> = <code><a class="el" href="classcanopy_1_1random_forest_base.html#a26bb427fd3744a3a5836ca939134ed4e">C_DEFAULT_BAGGING_PROPORTION</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>train_split_nodes</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>min_training_data</em> = <code><a class="el" href="classcanopy_1_1random_forest_base.html#af9d0fefed5fe6b43bc6a13ebfe0f65c4">C_DEFAULT_MIN_TRAINING_DATA</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Train the random forest model on training data. </p>
<p>This function trains the random forest model to produce a valid model that may used for predictions or stored for future use. It takes iterators pointing to the IDs of the training data and the corresponding label variables, and functors to generate parameters of the feature functor and evaluate the features.</p>
<p>This function uses OpenMP to train the trees in parallel threads.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIdIterator</td><td>Type of the iterator used to access the training IDs. Must be a random access iterator that dereferences to the ID type expected by feature_functor. </td></tr>
    <tr><td class="paramname">TLabelIterator</td><td>Type of the iterator used to access the label variables. Must be a random access iterator that dereferences to type TLabel. </td></tr>
    <tr><td class="paramname">TFeatureFunctor</td><td>Type of the feature_functor parameter. Must be a function object with an operator() of a specfied form. </td></tr>
    <tr><td class="paramname">TParameterFunctor</td><td>Type of the feature_functor parameter. Must be a function object with an operator() of the form void operator()(std::array&lt;int,TNumParams&gt;&amp;) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_id</td><td>Iterator to the ID of the first element in the training list. </td></tr>
    <tr><td class="paramname">last_id</td><td>Iterator to the ID of the last element in the training list. </td></tr>
    <tr><td class="paramname">first_label</td><td>Iterator to the label of the first element in the training list. This iterator will be advanced to find the labels of the subsequent IDs. </td></tr>
    <tr><td class="paramname">feature_functor</td><td>The function object that should be used to evaluate the features when training the split nodes. Must be safe to call from multiple threads simultaneously. </td></tr>
    <tr><td class="paramname">parameter_functor</td><td>The function object that should be called to generate a random set of split nodes parameters for use in the feature_functor. Should take a std::array&lt;int,TNumParams&gt; by reference and populate the elements with a valid combination of randomly chosen parameters. Must be safe to call from multiple threads simultaneously. </td></tr>
    <tr><td class="paramname">num_param_combos_to_test</td><td>The number of parameter combinations to test when training each split node. </td></tr>
    <tr><td class="paramname">bagging</td><td>If true, a random subset of the training data are used to train each tree. If false, the full set of training data are used to train each tree. Default: true. </td></tr>
    <tr><td class="paramname">bag_proportion</td><td>Proportion of the training data in the bag used to train each tree if bagging is true. If bagging is false, this parameter is ignored. If the value is not in the range 0 to 1, the training procedure will fail immediately. Default: C_DEFAULT_BAGGING_PROPORTION . </td></tr>
    <tr><td class="paramname">train_split_nodes</td><td>If true, a node distribution is fitted at every node in the forest, regardless of the lead nodes. This is typically slightly more time consuming and results is a larger .tr, but allows the trained model to be tested using a smaller depth than it was trained at. If false, the node distributions are only fitted to the leaf nodes. Default: true. </td></tr>
    <tr><td class="paramname">min_training_data</td><td>The threshold number of training data points in a node below which a leaf node is declared during training. Default: C_DEFAULT_MIN_TRAINING_DATA . </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a677e06d4acfdb2e0fdffc8e2971a66df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDerived , class TLabel , class TNodeDist , class TOutputDist , unsigned TNumParams&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcanopy_1_1random_forest_base.html">canopy::randomForestBase</a>&lt; TDerived, TLabel, TNodeDist, TOutputDist, TNumParams &gt;::writeToFile </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a trained model to a .tr file to be stored and re-used. </p>
<p>Ensure that <code><a class="el" href="classcanopy_1_1random_forest_base.html#a4b9f270fe6df6f17ac6f86f1b550fb4e" title="Store arbitrary strings that define parameters of the feature extraction process. ...">setFeatureDefinitionString()</a></code> is called before this function, otherwise a blank feature definition string will be stored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The full name and path of the file into which the model should be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the model was successfully written to the specified file, false otherwise. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/local/ball3996/dphil/github/canopy/include/canopy/randomForestBase/<a class="el" href="random_forest_base_8hpp_source.html">randomForestBase.hpp</a></li>
<li>/local/ball3996/dphil/github/canopy/include/canopy/randomForestBase/<a class="el" href="random_forest_base_8tpp.html">randomForestBase.tpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
